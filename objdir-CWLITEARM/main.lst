   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.section	.rodata.str1.1,"aMS",%progbits,1
  13              	.LC0:
  14 0000 65786563 		.ascii	"executable_name\000"
  14      75746162 
  14      6C655F6E 
  14      616D6500 
  15              	.LC1:
  16 0010 3300     		.ascii	"3\000"
  17              	.LC2:
  18 0012 342C352C 		.ascii	"4,5,5\000"
  18      3500
  19              	.LC3:
  20 0018 736F6674 		.ascii	"softmax,relu,tanh\000"
  20      6D61782C 
  20      72656C75 
  20      2C74616E 
  20      6800
  21              	.LC4:
  22 002a 3100     		.ascii	"1\000"
  23              	.LC5:
  24 002c 7369676D 		.ascii	"sigmoid\000"
  24      6F696400 
  25              	.LC6:
  26 0034 302E3031 		.ascii	"0.01\000"
  26      00
  27              	.LC7:
  28 0039 31303030 		.ascii	"10000 \000"
  28      302000
  29              	.LC8:
  30 0040 64617461 		.ascii	"data/data_train.csv\000"
  30      2F646174 
  30      615F7472 
  30      61696E2E 
  30      63737600 
  31              	.LC9:
  32 0054 31303936 		.ascii	"1096\000"
  32      00
  33              	.LC10:
  34 0059 3500     		.ascii	"5\000"
  35              	.LC11:
  36 005b 64617461 		.ascii	"data/data_test.csv\000"
  36      2F646174 
  36      615F7465 
  36      73742E63 
  36      737600
  37              	.LC12:
  38 006e 32373500 		.ascii	"275\000"
  39              		.text
  40              	.Ltext0:
  41              		.cfi_sections	.debug_frame
  42              		.section	.rodata.str1.1
  43              	.LC17:
  44 0072 4572726F 		.ascii	"Error: Number of hidden layers should be >= 0\000"
  44      723A204E 
  44      756D6265 
  44      72206F66 
  44      20686964 
  45              	.LC18:
  46 00a0 2C00     		.ascii	",\000"
  47              	.LC19:
  48 00a2 4572726F 		.ascii	"Error: Hidden layer sizes should be positive\000"
  48      723A2048 
  48      69646465 
  48      6E206C61 
  48      79657220 
  49              	.LC20:
  50 00cf 6964656E 		.ascii	"identity\000"
  50      74697479 
  50      00
  51              	.LC21:
  52 00d8 74616E68 		.ascii	"tanh\000"
  52      00
  53              	.LC22:
  54 00dd 72656C75 		.ascii	"relu\000"
  54      00
  55              	.LC23:
  56 00e2 736F6674 		.ascii	"softmax\000"
  56      6D617800 
  57              	.LC24:
  58 00ea 4572726F 		.ascii	"Error: Invalid value for hidden activation function"
  58      723A2049 
  58      6E76616C 
  58      69642076 
  58      616C7565 
  59 011d 00       		.ascii	"\000"
  60              	.LC25:
  61 011e 496E7075 		.ascii	"Input either identity or sigmoid or tanh or relu or"
  61      74206569 
  61      74686572 
  61      20696465 
  61      6E746974 
  62 0151 20736F66 		.ascii	" softmax for hidden activation function\000"
  62      746D6178 
  62      20666F72 
  62      20686964 
  62      64656E20 
  63              	.LC26:
  64 0179 4F757470 		.ascii	"Output layer size should be positive\000"
  64      7574206C 
  64      61796572 
  64      2073697A 
  64      65207368 
  65              	.LC27:
  66 019e 4572726F 		.ascii	"Error: Invalid value for output activation function"
  66      723A2049 
  66      6E76616C 
  66      69642076 
  66      616C7565 
  67 01d1 00       		.ascii	"\000"
  68              	.LC28:
  69 01d2 496E7075 		.ascii	"Input either identity or sigmoid or tanh or relu or"
  69      74206569 
  69      74686572 
  69      20696465 
  69      6E746974 
  70 0205 20736F66 		.ascii	" softmax for output activation function\000"
  70      746D6178 
  70      20666F72 
  70      206F7574 
  70      70757420 
  71              		.global	__aeabi_i2d
  72              	.LC29:
  73 022d 4D61782E 		.ascii	"Max. number of iterations value should be positive\000"
  73      206E756D 
  73      62657220 
  73      6F662069 
  73      74657261 
  74              		.section	.text.mlp,"ax",%progbits
  75              		.align	1
  76              		.global	mlp
  77              		.arch armv7e-m
  78              		.syntax unified
  79              		.thumb
  80              		.thumb_func
  81              		.fpu softvfp
  83              	mlp:
  84              	.LVL0:
  85              	.LFB3:
  86              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        **** Author: Manohar Mukku
   3:main.c        **** Date: 18.07.2018
   4:main.c        **** Desc: Multilayer Perceptron implementation in C
   5:main.c        **** GitHub: https://github.com/manoharmukku/multilayer-perceptron-in-c
   6:main.c        **** */
   7:main.c        **** 
   8:main.c        **** //#include "mlp_trainer.h"
   9:main.c        **** #include "mlp_classifier.h"
  10:main.c        **** //#include "read_csv.h"
  11:main.c        **** #include "simpleserial.h"
  12:main.c        **** #include "hal.h"
  13:main.c        **** 
  14:main.c        **** parameters* param;
  15:main.c        **** int* layer_sizes;
  16:main.c        **** 
  17:main.c        **** // uint8_t mlp_classifier_wrapper(uint8_t* arg1, uint8_t arg2) {
  18:main.c        **** //     // Call the mlp_classifier function with the global variables
  19:main.c        **** 
  20:main.c        **** //     mlp_classifier(param, layer_sizes);
  21:main.c        **** 
  22:main.c        **** //     // Return a dummy value (assuming simpleserial_addcmd doesn't need a meaningful return value
  23:main.c        **** //     return 0;
  24:main.c        **** // }
  25:main.c        **** 
  26:main.c        **** uint8_t mlp(uint8_t cmd, uint8_t scmd, uint8_t len, uint8_t *in) {
  87              		.loc 1 26 66 view -0
  88              		.cfi_startproc
  89              		@ args = 0, pretend = 0, frame = 960
  90              		@ frame_needed = 0, uses_anonymous_args = 0
  27:main.c        ****     /* Device reset detected */
  28:main.c        ****     //putch('r');
  29:main.c        ****     //printf("Device reset detected\n");
  30:main.c        ****     // putch('R');
  31:main.c        ****     // putch('E');
  32:main.c        ****     // putch('S');
  33:main.c        ****     // putch('E');
  34:main.c        ****     // putch('T');
  35:main.c        ****     // putch(' ');
  36:main.c        ****     // putch(' ');
  37:main.c        ****     // putch(' ');
  38:main.c        ****     // putch('\n');
  39:main.c        **** 
  40:main.c        **** 
  41:main.c        ****     //HARDCODED VALS
  42:main.c        ****     char *hardcoded_args[] = {
  91              		.loc 1 42 5 view .LVU1
  26:main.c        ****     /* Device reset detected */
  92              		.loc 1 26 66 is_stmt 0 view .LVU2
  93 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  94              	.LCFI0:
  95              		.cfi_def_cfa_offset 36
  96              		.cfi_offset 4, -36
  97              		.cfi_offset 5, -32
  98              		.cfi_offset 6, -28
  99              		.cfi_offset 7, -24
 100              		.cfi_offset 8, -20
 101              		.cfi_offset 9, -16
 102              		.cfi_offset 10, -12
 103              		.cfi_offset 11, -8
 104              		.cfi_offset 14, -4
 105              		.loc 1 42 11 view .LVU3
 106 0004 AC4D     		ldr	r5, .L53
 107 0006 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 108              	.LVL1:
  26:main.c        ****     /* Device reset detected */
 109              		.loc 1 26 66 view .LVU4
 110 0008 ADF5717D 		sub	sp, sp, #964
 111              	.LCFI1:
 112              		.cfi_def_cfa_offset 1000
 113              		.loc 1 42 11 view .LVU5
 114 000c 05AC     		add	r4, sp, #20
 115 000e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 116 0010 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 117 0012 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 118 0014 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 119 0016 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 120 0018 95E80700 		ldm	r5, {r0, r1, r2}
 121 001c 84E80700 		stm	r4, {r0, r1, r2}
  43:main.c        ****         "executable_name", // new_argv[0] is typically the program name
  44:main.c        ****         "3",                // Number of hidden layers
  45:main.c        ****         "4,5,5",            // Size of each hidden layer
  46:main.c        ****         "softmax,relu,tanh",
  47:main.c        ****         "1",           
  48:main.c        ****         "sigmoid",         
  49:main.c        ****         "0.01",              
  50:main.c        ****         "10000 ",     
  51:main.c        ****         "data/data_train.csv", 
  52:main.c        ****         "1096",             
  53:main.c        ****         "5",               
  54:main.c        ****         "data/data_test.csv",
  55:main.c        ****         "275",              
  56:main.c        ****         "5",                
  57:main.c        ****         NULL                // Sentinel to mark the end of the array
  58:main.c        ****     };
  59:main.c        **** 
  60:main.c        ****     int new_argc = sizeof(hardcoded_args) / sizeof(char *) - 1; // Exclude the NULL sentinel
 122              		.loc 1 60 5 is_stmt 1 view .LVU6
 123              	.LVL2:
  61:main.c        **** 
  62:main.c        ****     // Allocate memory for the new new_argv
  63:main.c        ****     char **new_argv = (char **)malloc(new_argc * sizeof(char *));
 124              		.loc 1 63 5 view .LVU7
 125              		.loc 1 63 32 is_stmt 0 view .LVU8
 126 0020 3820     		movs	r0, #56
 127 0022 FFF7FEFF 		bl	malloc
 128              	.LVL3:
 129 0026 05AC     		add	r4, sp, #20
 130 0028 0546     		mov	r5, r0
 131              	.LVL4:
  64:main.c        **** 
  65:main.c        ****     // Copy the hardcoded strings to the new new_argv
  66:main.c        ****     for (int i = 0; i < new_argc; i++) {
 132              		.loc 1 66 5 is_stmt 1 view .LVU9
 133              	.LBB2:
 134              		.loc 1 66 10 view .LVU10
 135              		.loc 1 66 21 view .LVU11
 136 002a 061F     		subs	r6, r0, #4
 137 002c 00F13408 		add	r8, r0, #52
 138              	.LVL5:
 139              	.L2:
  67:main.c        ****         new_argv[i] = (char *)malloc((strlen(hardcoded_args[i]) + 1) * sizeof(char));
 140              		.loc 1 67 9 discriminator 3 view .LVU12
 141              		.loc 1 67 60 is_stmt 0 discriminator 3 view .LVU13
 142 0030 54F8047B 		ldr	r7, [r4], #4
 143              		.loc 1 67 39 discriminator 3 view .LVU14
 144 0034 3846     		mov	r0, r7
 145 0036 FFF7FEFF 		bl	strlen
 146              	.LVL6:
 147              		.loc 1 67 31 discriminator 3 view .LVU15
 148 003a 0130     		adds	r0, r0, #1
 149 003c FFF7FEFF 		bl	malloc
 150              	.LVL7:
 151              		.loc 1 67 21 discriminator 3 view .LVU16
 152 0040 46F8040F 		str	r0, [r6, #4]!
  68:main.c        ****         strcpy(new_argv[i], hardcoded_args[i]);
 153              		.loc 1 68 9 is_stmt 1 discriminator 3 view .LVU17
 154 0044 3946     		mov	r1, r7
 155 0046 FFF7FEFF 		bl	strcpy
 156              	.LVL8:
  66:main.c        ****         new_argv[i] = (char *)malloc((strlen(hardcoded_args[i]) + 1) * sizeof(char));
 157              		.loc 1 66 35 discriminator 3 view .LVU18
  66:main.c        ****         new_argv[i] = (char *)malloc((strlen(hardcoded_args[i]) + 1) * sizeof(char));
 158              		.loc 1 66 21 discriminator 3 view .LVU19
  66:main.c        ****         new_argv[i] = (char *)malloc((strlen(hardcoded_args[i]) + 1) * sizeof(char));
 159              		.loc 1 66 5 is_stmt 0 discriminator 3 view .LVU20
 160 004a 4645     		cmp	r6, r8
 161 004c F0D1     		bne	.L2
 162              	.LBE2:
  69:main.c        ****     }
  70:main.c        **** 
  71:main.c        ****     /*
  72:main.c        ****     new_argv[0]: Executable file name Ex: a.out
  73:main.c        ****     new_argv[1]: Number of hidden layers Ex: 3
  74:main.c        ****     new_argv[2]: Size of each hidden layer separated by comma Ex: 4,5,5
  75:main.c        ****     new_argv[3]: Hidden activation functions (identity - 1, sigmoid - 2, tanh - 3, relu - 4, softma
  76:main.c        ****     new_argv[4]: Alpha (L2 Regularization parameter value)
  77:main.c        ****     new_argv[5]: Maximum number of iterations
  78:main.c        ****     new_argv[6]: Number of units in output layer
  79:main.c        ****     new_argv[7]: Output activation function (identity - 1, sigmoid - 2, tanh - 3, relu - 4, softmax
  80:main.c        ****     new_argv[8]: Name of the csv file containing the train dataset
  81:main.c        ****     new_argv[9]: Number of rows or samples in the train dataset
  82:main.c        ****     new_argv[10]: Number of features including the output variable in the train dataset
  83:main.c        ****     new_argv[11]: Name of the csv file containing the test dataset
  84:main.c        ****     new_argv[12]: Number of rows or samples in the test dataset
  85:main.c        ****     new_argv[13]: Number of features including the output variable in the test dataset
  86:main.c        ****     */
  87:main.c        **** 
  88:main.c        ****     // Sanity check of command line arguments
  89:main.c        ****     // if (argc != 14) {
  90:main.c        ****     //     // Print help for execution syntax
  91:main.c        ****     //     printf("\nExecution syntax:\n");
  92:main.c        ****     //     printf("-----------------\n");
  93:main.c        ****     //     printf("Argument 0: Executable file name Ex: ./MLP \n");
  94:main.c        ****     //     printf("Argument 1: Number of hidden layers Ex: 3 \n");
  95:main.c        ****     //     printf("Argument 2: Number of units in each hidden layer from left to right separated by
  96:main.c        ****     //     printf("Argument 3: Activation function of each hidden layer from left to right separate
  97:main.c        ****     //     printf("Argument 4: Number of units in output layer (Specify 1 for binary classification
  98:main.c        ****     //     printf("Argument 5: Output activation function Ex: sigmoid \n");
  99:main.c        ****     //     printf("Argument 6: Learning rate parameter Ex: 0.01 \n");
 100:main.c        ****     //     printf("Argument 7: Maximum number of iterations to run during training Ex: 10000 \n");
 101:main.c        ****     //     printf("Argument 8: Path of the csv file containing the train dataset Ex: data/data_trai
 102:main.c        ****     //     printf("Argument 9: Number of rows in the train dataset (Number of samples) Ex: 1096 \n"
 103:main.c        ****     //     printf("Argument 10: Number of columns in the train dataset (Number of input features + 
 104:main.c        ****     //     printf("Argument 11: Path of the csv file containing the test dataset Ex: data/data_test
 105:main.c        ****     //     printf("Argument 12: Number of rows in the test dataset (Number of samples) Ex: 275 \n")
 106:main.c        ****     //     printf("Argument 13: Number of columns in the test dataset (Number of input features + 1
 107:main.c        ****     //     printf("Example:\n--------\n~$ ./MLP 3 4,5,5 softmax,relu,tanh 1 sigmoid 0.01 10000 data
 108:main.c        **** 
 109:main.c        ****     //     exit(0);
 110:main.c        ****     // }
 111:main.c        **** 
 112:main.c        **** 
 113:main.c        ****     // Create memory for training parameters struct
 114:main.c        ****     param = (parameters*)malloc(sizeof(parameters));
 163              		.loc 1 114 5 is_stmt 1 view .LVU21
 164              		.loc 1 114 26 is_stmt 0 view .LVU22
 165 004e 4020     		movs	r0, #64
 166 0050 FFF7FEFF 		bl	malloc
 167              	.LVL9:
 168              		.loc 1 114 11 view .LVU23
 169 0054 994C     		ldr	r4, .L53+4
 170              		.loc 1 114 26 view .LVU24
 171 0056 0646     		mov	r6, r0
 172              		.loc 1 114 11 view .LVU25
 173 0058 2060     		str	r0, [r4]
 115:main.c        **** 
 116:main.c        ****     // Number of hidden layers
 117:main.c        ****     param->n_hidden = atoi(new_argv[1]);
 174              		.loc 1 117 5 is_stmt 1 view .LVU26
 175              		.loc 1 117 23 is_stmt 0 view .LVU27
 176 005a 6868     		ldr	r0, [r5, #4]
 177 005c FFF7FEFF 		bl	atoi
 178              	.LVL10:
 179              		.loc 1 117 21 view .LVU28
 180 0060 3060     		str	r0, [r6]
 118:main.c        ****     // Sanity check of number of hidden layers
 119:main.c        ****     if (param->n_hidden < 0) {
 181              		.loc 1 119 5 is_stmt 1 view .LVU29
 182              		.loc 1 119 14 is_stmt 0 view .LVU30
 183 0062 2668     		ldr	r6, [r4]
 184 0064 3068     		ldr	r0, [r6]
 185              		.loc 1 119 8 view .LVU31
 186 0066 0028     		cmp	r0, #0
 187 0068 05DA     		bge	.L3
 120:main.c        ****         printf("Error: Number of hidden layers should be >= 0\n");
 188              		.loc 1 120 9 is_stmt 1 view .LVU32
 189 006a 9548     		ldr	r0, .L53+8
 190              	.LVL11:
 191              	.L52:
 121:main.c        ****         exit(0);
 122:main.c        ****     }
 123:main.c        **** 
 124:main.c        ****     // Size of each hidden layer
 125:main.c        ****     param->hidden_layers_size = (int*)malloc(param->n_hidden * sizeof(int));
 126:main.c        ****     int i;
 127:main.c        ****     char* tok;
 128:main.c        ****     for (i = 0, tok = strtok(new_argv[2], ","); i < param->n_hidden; i++) {
 129:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 130:main.c        ****         // Sanity check of size of hidden layer
 131:main.c        ****         if (param->hidden_layers_size[i] <= 0) {
 132:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 192              		.loc 1 132 13 is_stmt 0 view .LVU33
 193 006c FFF7FEFF 		bl	puts
 194              	.LVL12:
 133:main.c        ****             exit(0);
 195              		.loc 1 133 13 is_stmt 1 view .LVU34
 196 0070 0020     		movs	r0, #0
 197 0072 FFF7FEFF 		bl	exit
 198              	.LVL13:
 199              	.L3:
 125:main.c        ****     int i;
 200              		.loc 1 125 5 view .LVU35
 125:main.c        ****     int i;
 201              		.loc 1 125 39 is_stmt 0 view .LVU36
 202 0076 8000     		lsls	r0, r0, #2
 203 0078 FFF7FEFF 		bl	malloc
 204              	.LVL14:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 205              		.loc 1 128 23 view .LVU37
 206 007c 9149     		ldr	r1, .L53+12
 125:main.c        ****     int i;
 207              		.loc 1 125 31 view .LVU38
 208 007e 7060     		str	r0, [r6, #4]
 126:main.c        ****     char* tok;
 209              		.loc 1 126 5 is_stmt 1 view .LVU39
 127:main.c        ****     for (i = 0, tok = strtok(new_argv[2], ","); i < param->n_hidden; i++) {
 210              		.loc 1 127 5 view .LVU40
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 211              		.loc 1 128 5 view .LVU41
 212              	.LVL15:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 213              		.loc 1 128 23 is_stmt 0 view .LVU42
 214 0080 A868     		ldr	r0, [r5, #8]
 134:main.c        ****         }
 135:main.c        ****         tok = strtok(NULL, ",");
 215              		.loc 1 135 15 view .LVU43
 216 0082 DFF84082 		ldr	r8, .L53+12
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 217              		.loc 1 128 23 view .LVU44
 218 0086 FFF7FEFF 		bl	strtok
 219              	.LVL16:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 220              		.loc 1 128 12 view .LVU45
 221 008a 0026     		movs	r6, #0
 222              	.LVL17:
 223              	.L4:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 224              		.loc 1 128 49 is_stmt 1 discriminator 1 view .LVU46
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 225              		.loc 1 128 58 is_stmt 0 discriminator 1 view .LVU47
 226 008c 2768     		ldr	r7, [r4]
 227 008e 3B68     		ldr	r3, [r7]
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 228              		.loc 1 128 5 discriminator 1 view .LVU48
 229 0090 B342     		cmp	r3, r6
 230 0092 1CDC     		bgt	.L6
 136:main.c        ****     }
 137:main.c        **** 
 138:main.c        ****     // Hidden activation functions - Activation functions for each hidden layer
 139:main.c        ****     param->hidden_activation_functions = (int*)malloc(param->n_hidden * sizeof(int));
 231              		.loc 1 139 5 is_stmt 1 view .LVU49
 232              		.loc 1 139 48 is_stmt 0 view .LVU50
 233 0094 9800     		lsls	r0, r3, #2
 234 0096 FFF7FEFF 		bl	malloc
 235              	.LVL18:
 140:main.c        ****     for (i = 0, tok = strtok(new_argv[3], ","); i < param->n_hidden; i++) {
 236              		.loc 1 140 23 view .LVU51
 237 009a 8A49     		ldr	r1, .L53+12
 139:main.c        ****     for (i = 0, tok = strtok(new_argv[3], ","); i < param->n_hidden; i++) {
 238              		.loc 1 139 40 view .LVU52
 239 009c B860     		str	r0, [r7, #8]
 240              		.loc 1 140 5 is_stmt 1 view .LVU53
 241              	.LVL19:
 242              		.loc 1 140 23 is_stmt 0 view .LVU54
 243 009e E868     		ldr	r0, [r5, #12]
 141:main.c        ****         if (strcmp(tok, "identity") == 0) {
 142:main.c        ****             param->hidden_activation_functions[i] = 1;
 143:main.c        ****         }
 144:main.c        ****         else if (strcmp(tok, "sigmoid") == 0) {
 244              		.loc 1 144 18 view .LVU55
 245 00a0 DFF824A2 		ldr	r10, .L53+16
 145:main.c        ****             param->hidden_activation_functions[i] = 2;
 146:main.c        ****         }
 147:main.c        ****         else if (strcmp(tok, "tanh") == 0) {
 246              		.loc 1 147 18 view .LVU56
 247 00a4 DFF824B2 		ldr	fp, .L53+20
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 248              		.loc 1 140 23 view .LVU57
 249 00a8 FFF7FEFF 		bl	strtok
 250              	.LVL20:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 251              		.loc 1 140 5 view .LVU58
 252 00ac 0026     		movs	r6, #0
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 253              		.loc 1 140 23 view .LVU59
 254 00ae 8146     		mov	r9, r0
 255              	.LVL21:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 256              		.loc 1 140 12 view .LVU60
 257 00b0 B046     		mov	r8, r6
 258              	.LVL22:
 259              	.L7:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 260              		.loc 1 140 49 is_stmt 1 discriminator 1 view .LVU61
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 261              		.loc 1 140 58 is_stmt 0 discriminator 1 view .LVU62
 262 00b2 2768     		ldr	r7, [r4]
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 263              		.loc 1 140 5 discriminator 1 view .LVU63
 264 00b4 3A68     		ldr	r2, [r7]
 265 00b6 4245     		cmp	r2, r8
 266 00b8 1CDC     		bgt	.L14
 148:main.c        ****             param->hidden_activation_functions[i] = 3;
 149:main.c        ****         }
 150:main.c        ****         else if (strcmp(tok, "relu") == 0) {
 151:main.c        ****             param->hidden_activation_functions[i] = 4;
 152:main.c        ****         }
 153:main.c        ****         else if (strcmp(tok, "softmax") == 0) {
 154:main.c        ****             param->hidden_activation_functions[i] = 5;
 155:main.c        ****         }
 156:main.c        ****         else {
 157:main.c        ****             printf("Error: Invalid value for hidden activation function\n");
 158:main.c        ****             printf("Input either identity or sigmoid or tanh or relu or softmax for hidden activati
 159:main.c        ****             exit(0);
 160:main.c        ****         }
 161:main.c        **** 
 162:main.c        ****         tok = strtok(NULL, ",");
 163:main.c        ****     }
 164:main.c        **** 
 165:main.c        ****     // Output layer size
 166:main.c        ****     param->output_layer_size = atoi(new_argv[4]);
 267              		.loc 1 166 5 is_stmt 1 view .LVU64
 268              		.loc 1 166 32 is_stmt 0 view .LVU65
 269 00ba 2869     		ldr	r0, [r5, #16]
 270              	.LVL23:
 271              		.loc 1 166 32 view .LVU66
 272 00bc FFF7FEFF 		bl	atoi
 273              	.LVL24:
 167:main.c        ****     if (param->output_layer_size <= 0) {
 274              		.loc 1 167 14 view .LVU67
 275 00c0 2668     		ldr	r6, [r4]
 166:main.c        ****     if (param->output_layer_size <= 0) {
 276              		.loc 1 166 30 view .LVU68
 277 00c2 3862     		str	r0, [r7, #32]
 278              		.loc 1 167 5 is_stmt 1 view .LVU69
 279              		.loc 1 167 8 is_stmt 0 view .LVU70
 280 00c4 336A     		ldr	r3, [r6, #32]
 281 00c6 002B     		cmp	r3, #0
 282 00c8 4ADC     		bgt	.L15
 168:main.c        ****         printf("Output layer size should be positive\n");
 283              		.loc 1 168 9 is_stmt 1 view .LVU71
 284 00ca 8148     		ldr	r0, .L53+24
 285 00cc CEE7     		b	.L52
 286              	.LVL25:
 287              	.L6:
 129:main.c        ****         // Sanity check of size of hidden layer
 288              		.loc 1 129 9 view .LVU72
 129:main.c        ****         // Sanity check of size of hidden layer
 289              		.loc 1 129 34 is_stmt 0 view .LVU73
 290 00ce 7F68     		ldr	r7, [r7, #4]
 129:main.c        ****         // Sanity check of size of hidden layer
 291              		.loc 1 129 40 view .LVU74
 292 00d0 FFF7FEFF 		bl	atoi
 293              	.LVL26:
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 294              		.loc 1 131 18 view .LVU75
 295 00d4 2368     		ldr	r3, [r4]
 129:main.c        ****         // Sanity check of size of hidden layer
 296              		.loc 1 129 38 view .LVU76
 297 00d6 47F82600 		str	r0, [r7, r6, lsl #2]
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 298              		.loc 1 131 9 is_stmt 1 view .LVU77
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 299              		.loc 1 131 38 is_stmt 0 view .LVU78
 300 00da 5B68     		ldr	r3, [r3, #4]
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 301              		.loc 1 131 12 view .LVU79
 302 00dc 53F82630 		ldr	r3, [r3, r6, lsl #2]
 303 00e0 002B     		cmp	r3, #0
 304 00e2 01DC     		bgt	.L5
 132:main.c        ****             exit(0);
 305              		.loc 1 132 13 is_stmt 1 view .LVU80
 306 00e4 7B48     		ldr	r0, .L53+28
 307 00e6 C1E7     		b	.L52
 308              	.L5:
 135:main.c        ****     }
 309              		.loc 1 135 9 discriminator 2 view .LVU81
 135:main.c        ****     }
 310              		.loc 1 135 15 is_stmt 0 discriminator 2 view .LVU82
 311 00e8 4146     		mov	r1, r8
 312 00ea 0020     		movs	r0, #0
 313 00ec FFF7FEFF 		bl	strtok
 314              	.LVL27:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 315              		.loc 1 128 70 is_stmt 1 discriminator 2 view .LVU83
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 316              		.loc 1 128 71 is_stmt 0 discriminator 2 view .LVU84
 317 00f0 0136     		adds	r6, r6, #1
 318              	.LVL28:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 319              		.loc 1 128 71 discriminator 2 view .LVU85
 320 00f2 CBE7     		b	.L4
 321              	.LVL29:
 322              	.L14:
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 323              		.loc 1 141 9 is_stmt 1 view .LVU86
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 324              		.loc 1 141 13 is_stmt 0 view .LVU87
 325 00f4 7849     		ldr	r1, .L53+32
 326 00f6 4846     		mov	r0, r9
 327              	.LVL30:
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 328              		.loc 1 141 13 view .LVU88
 329 00f8 FFF7FEFF 		bl	strcmp
 330              	.LVL31:
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 331              		.loc 1 141 12 view .LVU89
 332 00fc 58B9     		cbnz	r0, .L8
 142:main.c        ****         }
 333              		.loc 1 142 13 is_stmt 1 view .LVU90
 142:main.c        ****         }
 334              		.loc 1 142 51 is_stmt 0 view .LVU91
 335 00fe BB68     		ldr	r3, [r7, #8]
 336 0100 0122     		movs	r2, #1
 337              	.L50:
 154:main.c        ****         }
 338              		.loc 1 154 51 view .LVU92
 339 0102 9A51     		str	r2, [r3, r6]
 162:main.c        ****     }
 340              		.loc 1 162 9 is_stmt 1 view .LVU93
 162:main.c        ****     }
 341              		.loc 1 162 15 is_stmt 0 view .LVU94
 342 0104 6F49     		ldr	r1, .L53+12
 343 0106 0020     		movs	r0, #0
 344 0108 FFF7FEFF 		bl	strtok
 345              	.LVL32:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 346              		.loc 1 140 71 view .LVU95
 347 010c 08F10108 		add	r8, r8, #1
 348              	.LVL33:
 162:main.c        ****     }
 349              		.loc 1 162 15 view .LVU96
 350 0110 8146     		mov	r9, r0
 351              	.LVL34:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 352              		.loc 1 140 70 is_stmt 1 view .LVU97
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 353              		.loc 1 140 70 is_stmt 0 view .LVU98
 354 0112 0436     		adds	r6, r6, #4
 355 0114 CDE7     		b	.L7
 356              	.LVL35:
 357              	.L8:
 144:main.c        ****             param->hidden_activation_functions[i] = 2;
 358              		.loc 1 144 14 is_stmt 1 view .LVU99
 144:main.c        ****             param->hidden_activation_functions[i] = 2;
 359              		.loc 1 144 18 is_stmt 0 view .LVU100
 360 0116 5146     		mov	r1, r10
 361 0118 4846     		mov	r0, r9
 362 011a FFF7FEFF 		bl	strcmp
 363              	.LVL36:
 144:main.c        ****             param->hidden_activation_functions[i] = 2;
 364              		.loc 1 144 17 view .LVU101
 365 011e 10B9     		cbnz	r0, .L10
 145:main.c        ****         }
 366              		.loc 1 145 13 is_stmt 1 view .LVU102
 145:main.c        ****         }
 367              		.loc 1 145 51 is_stmt 0 view .LVU103
 368 0120 BB68     		ldr	r3, [r7, #8]
 369 0122 0222     		movs	r2, #2
 370 0124 EDE7     		b	.L50
 371              	.L10:
 147:main.c        ****             param->hidden_activation_functions[i] = 3;
 372              		.loc 1 147 14 is_stmt 1 view .LVU104
 147:main.c        ****             param->hidden_activation_functions[i] = 3;
 373              		.loc 1 147 18 is_stmt 0 view .LVU105
 374 0126 5946     		mov	r1, fp
 375 0128 4846     		mov	r0, r9
 376 012a FFF7FEFF 		bl	strcmp
 377              	.LVL37:
 147:main.c        ****             param->hidden_activation_functions[i] = 3;
 378              		.loc 1 147 17 view .LVU106
 379 012e 10B9     		cbnz	r0, .L11
 148:main.c        ****         }
 380              		.loc 1 148 13 is_stmt 1 view .LVU107
 148:main.c        ****         }
 381              		.loc 1 148 51 is_stmt 0 view .LVU108
 382 0130 BB68     		ldr	r3, [r7, #8]
 383 0132 0322     		movs	r2, #3
 384 0134 E5E7     		b	.L50
 385              	.L11:
 150:main.c        ****             param->hidden_activation_functions[i] = 4;
 386              		.loc 1 150 14 is_stmt 1 view .LVU109
 150:main.c        ****             param->hidden_activation_functions[i] = 4;
 387              		.loc 1 150 18 is_stmt 0 view .LVU110
 388 0136 6949     		ldr	r1, .L53+36
 389 0138 4846     		mov	r0, r9
 390 013a FFF7FEFF 		bl	strcmp
 391              	.LVL38:
 150:main.c        ****             param->hidden_activation_functions[i] = 4;
 392              		.loc 1 150 17 view .LVU111
 393 013e 10B9     		cbnz	r0, .L12
 151:main.c        ****         }
 394              		.loc 1 151 13 is_stmt 1 view .LVU112
 151:main.c        ****         }
 395              		.loc 1 151 51 is_stmt 0 view .LVU113
 396 0140 BB68     		ldr	r3, [r7, #8]
 397 0142 0422     		movs	r2, #4
 398 0144 DDE7     		b	.L50
 399              	.L12:
 153:main.c        ****             param->hidden_activation_functions[i] = 5;
 400              		.loc 1 153 14 is_stmt 1 view .LVU114
 153:main.c        ****             param->hidden_activation_functions[i] = 5;
 401              		.loc 1 153 18 is_stmt 0 view .LVU115
 402 0146 6649     		ldr	r1, .L53+40
 403 0148 4846     		mov	r0, r9
 404 014a FFF7FEFF 		bl	strcmp
 405              	.LVL39:
 153:main.c        ****             param->hidden_activation_functions[i] = 5;
 406              		.loc 1 153 17 view .LVU116
 407 014e 10B9     		cbnz	r0, .L13
 154:main.c        ****         }
 408              		.loc 1 154 13 is_stmt 1 view .LVU117
 154:main.c        ****         }
 409              		.loc 1 154 51 is_stmt 0 view .LVU118
 410 0150 BB68     		ldr	r3, [r7, #8]
 411 0152 0522     		movs	r2, #5
 412 0154 D5E7     		b	.L50
 413              	.L13:
 157:main.c        ****             printf("Input either identity or sigmoid or tanh or relu or softmax for hidden activati
 414              		.loc 1 157 13 is_stmt 1 view .LVU119
 415 0156 6348     		ldr	r0, .L53+44
 416 0158 FFF7FEFF 		bl	puts
 417              	.LVL40:
 158:main.c        ****             exit(0);
 418              		.loc 1 158 13 view .LVU120
 419 015c 6248     		ldr	r0, .L53+48
 420 015e 85E7     		b	.L52
 421              	.L15:
 169:main.c        ****         exit(0);
 170:main.c        ****     }
 171:main.c        **** 
 172:main.c        ****     // Output activation function
 173:main.c        ****     if (strcmp(new_argv[5], "identity") == 0) {
 422              		.loc 1 173 5 view .LVU121
 423              		.loc 1 173 9 is_stmt 0 view .LVU122
 424 0160 6F69     		ldr	r7, [r5, #20]
 425 0162 5D49     		ldr	r1, .L53+32
 426 0164 3846     		mov	r0, r7
 427 0166 FFF7FEFF 		bl	strcmp
 428              	.LVL41:
 429              		.loc 1 173 8 view .LVU123
 430 016a 98B9     		cbnz	r0, .L16
 174:main.c        ****         param->output_activation_function = 1;
 431              		.loc 1 174 9 is_stmt 1 view .LVU124
 432              		.loc 1 174 43 is_stmt 0 view .LVU125
 433 016c 0123     		movs	r3, #1
 434              	.L51:
 175:main.c        ****     }
 176:main.c        ****     else if (strcmp(new_argv[5], "sigmoid") == 0) {
 177:main.c        ****         param->output_activation_function = 2;
 178:main.c        ****     }
 179:main.c        ****     else if (strcmp(new_argv[5], "tanh") == 0) {
 180:main.c        ****         param->output_activation_function = 3;
 181:main.c        ****     }
 182:main.c        ****     else if (strcmp(new_argv[5], "relu") == 0) {
 183:main.c        ****         param->output_activation_function = 4;
 184:main.c        ****     }
 185:main.c        ****     else if (strcmp(new_argv[5], "softmax") == 0) {
 186:main.c        ****         param->output_activation_function = 5;
 435              		.loc 1 186 43 view .LVU126
 436 016e 7362     		str	r3, [r6, #36]
 187:main.c        ****     }
 188:main.c        ****     else {
 189:main.c        ****         printf("Error: Invalid value for output activation function\n");
 190:main.c        ****         printf("Input either identity or sigmoid or tanh or relu or softmax for output activation f
 191:main.c        ****         exit(0);
 192:main.c        ****     }
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        ****     // L2 Regularization parameter
 196:main.c        ****     param->learning_rate = atoi(new_argv[6]);
 437              		.loc 1 196 5 is_stmt 1 view .LVU127
 438              		.loc 1 196 28 is_stmt 0 view .LVU128
 439 0170 A869     		ldr	r0, [r5, #24]
 440 0172 FFF7FEFF 		bl	atoi
 441              	.LVL42:
 442              		.loc 1 196 26 view .LVU129
 443 0176 FFF7FEFF 		bl	__aeabi_i2d
 444              	.LVL43:
 445              		.loc 1 196 10 view .LVU130
 446 017a 2668     		ldr	r6, [r4]
 447              		.loc 1 196 26 view .LVU131
 448 017c C6E90401 		strd	r0, [r6, #16]
 197:main.c        **** 
 198:main.c        ****     // Max. number of iterations
 199:main.c        ****     param->n_iterations_max = atoi(new_argv[7]);
 449              		.loc 1 199 5 is_stmt 1 view .LVU132
 450              		.loc 1 199 31 is_stmt 0 view .LVU133
 451 0180 E869     		ldr	r0, [r5, #28]
 452 0182 FFF7FEFF 		bl	atoi
 453              	.LVL44:
 200:main.c        ****     if (param->n_iterations_max <= 0) {
 454              		.loc 1 200 14 view .LVU134
 455 0186 2568     		ldr	r5, [r4]
 456              	.LVL45:
 199:main.c        ****     if (param->n_iterations_max <= 0) {
 457              		.loc 1 199 29 view .LVU135
 458 0188 B061     		str	r0, [r6, #24]
 459              		.loc 1 200 5 is_stmt 1 view .LVU136
 460              		.loc 1 200 8 is_stmt 0 view .LVU137
 461 018a AB69     		ldr	r3, [r5, #24]
 462 018c 002B     		cmp	r3, #0
 463 018e 22DC     		bgt	.L22
 201:main.c        ****         printf("Max. number of iterations value should be positive\n");
 464              		.loc 1 201 9 is_stmt 1 view .LVU138
 465 0190 5648     		ldr	r0, .L53+52
 466 0192 6BE7     		b	.L52
 467              	.LVL46:
 468              	.L16:
 176:main.c        ****         param->output_activation_function = 2;
 469              		.loc 1 176 10 view .LVU139
 176:main.c        ****         param->output_activation_function = 2;
 470              		.loc 1 176 14 is_stmt 0 view .LVU140
 471 0194 4C49     		ldr	r1, .L53+16
 472 0196 3846     		mov	r0, r7
 473 0198 FFF7FEFF 		bl	strcmp
 474              	.LVL47:
 176:main.c        ****         param->output_activation_function = 2;
 475              		.loc 1 176 13 view .LVU141
 476 019c 08B9     		cbnz	r0, .L18
 177:main.c        ****     }
 477              		.loc 1 177 9 is_stmt 1 view .LVU142
 177:main.c        ****     }
 478              		.loc 1 177 43 is_stmt 0 view .LVU143
 479 019e 0223     		movs	r3, #2
 480 01a0 E5E7     		b	.L51
 481              	.L18:
 179:main.c        ****         param->output_activation_function = 3;
 482              		.loc 1 179 10 is_stmt 1 view .LVU144
 179:main.c        ****         param->output_activation_function = 3;
 483              		.loc 1 179 14 is_stmt 0 view .LVU145
 484 01a2 4A49     		ldr	r1, .L53+20
 485 01a4 3846     		mov	r0, r7
 486 01a6 FFF7FEFF 		bl	strcmp
 487              	.LVL48:
 179:main.c        ****         param->output_activation_function = 3;
 488              		.loc 1 179 13 view .LVU146
 489 01aa 08B9     		cbnz	r0, .L19
 180:main.c        ****     }
 490              		.loc 1 180 9 is_stmt 1 view .LVU147
 180:main.c        ****     }
 491              		.loc 1 180 43 is_stmt 0 view .LVU148
 492 01ac 0323     		movs	r3, #3
 493 01ae DEE7     		b	.L51
 494              	.L19:
 182:main.c        ****         param->output_activation_function = 4;
 495              		.loc 1 182 10 is_stmt 1 view .LVU149
 182:main.c        ****         param->output_activation_function = 4;
 496              		.loc 1 182 14 is_stmt 0 view .LVU150
 497 01b0 4A49     		ldr	r1, .L53+36
 498 01b2 3846     		mov	r0, r7
 499 01b4 FFF7FEFF 		bl	strcmp
 500              	.LVL49:
 182:main.c        ****         param->output_activation_function = 4;
 501              		.loc 1 182 13 view .LVU151
 502 01b8 08B9     		cbnz	r0, .L20
 183:main.c        ****     }
 503              		.loc 1 183 9 is_stmt 1 view .LVU152
 183:main.c        ****     }
 504              		.loc 1 183 43 is_stmt 0 view .LVU153
 505 01ba 0423     		movs	r3, #4
 506 01bc D7E7     		b	.L51
 507              	.L20:
 185:main.c        ****         param->output_activation_function = 5;
 508              		.loc 1 185 10 is_stmt 1 view .LVU154
 185:main.c        ****         param->output_activation_function = 5;
 509              		.loc 1 185 14 is_stmt 0 view .LVU155
 510 01be 4849     		ldr	r1, .L53+40
 511 01c0 3846     		mov	r0, r7
 512 01c2 FFF7FEFF 		bl	strcmp
 513              	.LVL50:
 185:main.c        ****         param->output_activation_function = 5;
 514              		.loc 1 185 13 view .LVU156
 515 01c6 08B9     		cbnz	r0, .L21
 186:main.c        ****     }
 516              		.loc 1 186 9 is_stmt 1 view .LVU157
 186:main.c        ****     }
 517              		.loc 1 186 43 is_stmt 0 view .LVU158
 518 01c8 0523     		movs	r3, #5
 519 01ca D0E7     		b	.L51
 520              	.L21:
 189:main.c        ****         printf("Input either identity or sigmoid or tanh or relu or softmax for output activation f
 521              		.loc 1 189 9 is_stmt 1 view .LVU159
 522 01cc 4848     		ldr	r0, .L53+56
 523 01ce FFF7FEFF 		bl	puts
 524              	.LVL51:
 190:main.c        ****         exit(0);
 525              		.loc 1 190 9 view .LVU160
 526 01d2 4848     		ldr	r0, .L53+60
 527 01d4 4AE7     		b	.L52
 528              	.LVL52:
 529              	.L22:
 202:main.c        ****         exit(0);
 203:main.c        ****     }
 204:main.c        **** 
 205:main.c        ****     // Momentum
 206:main.c        ****     //param->momentum = atoi(new_argv[6]);
 207:main.c        **** 
 208:main.c        ****     // Get the parameters of the train dataset
 209:main.c        ****     //char* train_filename = new_argv[8];
 210:main.c        ****     //param->train_sample_size = atoi(new_argv[9]);
 211:main.c        ****     // Feature size = Number of input features + 1 output feature
 212:main.c        ****     //param->feature_size = atoi(new_argv[10]);
 213:main.c        **** 
 214:main.c        ****     // Create 2D array memory for the dataset
 215:main.c        ****     //param->data_train = (double**)malloc(param->train_sample_size * sizeof(double*));
 216:main.c        ****     //for (i = 0; i < param->train_sample_size; i++)
 217:main.c        ****     //    param->data_train[i] = (double*)malloc(param->feature_size * sizeof(double));
 218:main.c        **** 
 219:main.c        ****     // Read the train dataset from the csv into the 2D array
 220:main.c        ****     //read_csv(train_filename, param->train_sample_size, param->feature_size, param->data_train);
 221:main.c        ****     
 222:main.c        ****     double test_lines[][5] = {
 530              		.loc 1 222 5 view .LVU161
 531              		.loc 1 222 12 is_stmt 0 view .LVU162
 532 01d6 4849     		ldr	r1, .L53+64
 533 01d8 C822     		movs	r2, #200
 534 01da 14A8     		add	r0, sp, #80
 535 01dc FFF7FEFF 		bl	memcpy
 536              	.LVL53:
 223:main.c        ****         {1.602, 6.1251, 0.5292399999999999, 0.4788600000000001, 0},
 224:main.c        ****         {-2.2918, -7.2570000000000014, 7.9597, 0.9211, 1},
 225:main.c        ****         {-0.6907800000000001, -0.5007699999999999, -0.35417, 0.47498, 1},
 226:main.c        ****         {1.6408, 4.2503, -4.9023, -2.6621, 1},
 227:main.c        ****         {3.577, 2.4004, 1.8908, 0.73231, 0},
 228:main.c        ****     };
 229:main.c        **** 
 230:main.c        ****     int test_sample_size = sizeof(test_lines) / sizeof(test_lines[0]);
 537              		.loc 1 230 5 is_stmt 1 view .LVU163
 231:main.c        ****     int feature_size = sizeof(test_lines[0]) / sizeof(double);
 538              		.loc 1 231 5 view .LVU164
 232:main.c        **** 
 233:main.c        ****     // Get the parameters of the test dataset
 234:main.c        ****     //char* test_filename = new_argv[11];
 235:main.c        ****     //param->test_sample_size = atoi(new_argv[12]);
 236:main.c        ****     // Feature size = Number of input features + 1 output feature
 237:main.c        ****     //param->feature_size = atoi(new_argv[13]);
 238:main.c        **** 
 239:main.c        ****    // Create 2D array memory for the test data
 240:main.c        ****     param->data_test = (double **)malloc(test_sample_size * sizeof(double *));
 539              		.loc 1 240 5 view .LVU165
 540              		.loc 1 240 35 is_stmt 0 view .LVU166
 541 01e0 1420     		movs	r0, #20
 542 01e2 FFF7FEFF 		bl	malloc
 543              	.LVL54:
 544 01e6 0DF15008 		add	r8, sp, #80
 545              	.LVL55:
 546              		.loc 1 240 22 view .LVU167
 547 01ea E862     		str	r0, [r5, #44]
 241:main.c        ****     for (int i = 0; i < test_sample_size; i++) {
 548              		.loc 1 241 5 is_stmt 1 view .LVU168
 549              	.LBB3:
 550              		.loc 1 241 10 view .LVU169
 551              	.LVL56:
 552              		.loc 1 241 21 view .LVU170
 553              	.LBE3:
 240:main.c        ****     for (int i = 0; i < test_sample_size; i++) {
 554              		.loc 1 240 22 is_stmt 0 view .LVU171
 555 01ec 4FF00009 		mov	r9, #0
 556              	.LVL57:
 557              	.L23:
 558              	.LBB4:
 242:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 559              		.loc 1 242 9 is_stmt 1 discriminator 3 view .LVU172
 560              		.loc 1 242 41 is_stmt 0 discriminator 3 view .LVU173
 561 01f0 2820     		movs	r0, #40
 562              		.loc 1 242 25 discriminator 3 view .LVU174
 563 01f2 EF6A     		ldr	r7, [r5, #44]
 564              		.loc 1 242 41 discriminator 3 view .LVU175
 565 01f4 FFF7FEFF 		bl	malloc
 566              	.LVL58:
 567              		.loc 1 242 29 discriminator 3 view .LVU176
 568 01f8 47F80900 		str	r0, [r7, r9]
 243:main.c        ****         memcpy(param->data_test[i], test_lines[i], feature_size * sizeof(double));
 569              		.loc 1 243 9 is_stmt 1 discriminator 3 view .LVU177
 570 01fc 4746     		mov	r7, r8
 242:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 571              		.loc 1 242 41 is_stmt 0 discriminator 3 view .LVU178
 572 01fe 0646     		mov	r6, r0
 573              		.loc 1 243 9 discriminator 3 view .LVU179
 574 0200 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 575 0202 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 576 0204 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 577 0206 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 578 0208 97E80300 		ldm	r7, {r0, r1}
 241:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 579              		.loc 1 241 5 discriminator 3 view .LVU180
 580 020c 09F10409 		add	r9, r9, #4
 581 0210 B9F1140F 		cmp	r9, #20
 582              		.loc 1 243 9 discriminator 3 view .LVU181
 583 0214 86E80300 		stm	r6, {r0, r1}
 241:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 584              		.loc 1 241 43 is_stmt 1 discriminator 3 view .LVU182
 241:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 585              		.loc 1 241 21 discriminator 3 view .LVU183
 241:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 586              		.loc 1 241 5 is_stmt 0 discriminator 3 view .LVU184
 587 0218 08F12808 		add	r8, r8, #40
 588 021c E8D1     		bne	.L23
 589              	.LBE4:
 244:main.c        ****     }
 245:main.c        **** 
 246:main.c        ****     param->test_sample_size = test_sample_size;
 590              		.loc 1 246 5 is_stmt 1 view .LVU185
 247:main.c        ****     param->feature_size = feature_size;
 248:main.c        **** 
 249:main.c        ****     // Read the test dataset from the csv into the 2D array
 250:main.c        ****     //read_csv(test_filename, param->test_sample_size, param->feature_size, param->data_test);
 251:main.c        **** 
 252:main.c        ****     // Total number of layers
 253:main.c        ****     int n_layers = param->n_hidden + 2;
 591              		.loc 1 253 25 is_stmt 0 view .LVU186
 592 021e 2F68     		ldr	r7, [r5]
 246:main.c        ****     param->feature_size = feature_size;
 593              		.loc 1 246 29 view .LVU187
 594 0220 0523     		movs	r3, #5
 595 0222 AB63     		str	r3, [r5, #56]
 247:main.c        ****     param->feature_size = feature_size;
 596              		.loc 1 247 5 is_stmt 1 view .LVU188
 247:main.c        ****     param->feature_size = feature_size;
 597              		.loc 1 247 25 is_stmt 0 view .LVU189
 598 0224 2B63     		str	r3, [r5, #48]
 599              		.loc 1 253 5 is_stmt 1 view .LVU190
 600              	.LVL59:
 254:main.c        **** 
 255:main.c        ****     // Save the sizes of layers in an array
 256:main.c        ****     layer_sizes = (int*)calloc(n_layers, sizeof(int));
 601              		.loc 1 256 5 view .LVU191
 602              		.loc 1 256 25 is_stmt 0 view .LVU192
 603 0226 0421     		movs	r1, #4
 604 0228 B81C     		adds	r0, r7, #2
 605              	.LVL60:
 606              		.loc 1 256 25 view .LVU193
 607 022a FFF7FEFF 		bl	calloc
 608              	.LVL61:
 257:main.c        **** 
 258:main.c        ****     layer_sizes[0] = param->feature_size - 1;
 609              		.loc 1 258 20 view .LVU194
 610 022e 0423     		movs	r3, #4
 611 0230 0360     		str	r3, [r0]
 259:main.c        ****     layer_sizes[n_layers-1] = param->output_layer_size;
 612              		.loc 1 259 16 view .LVU195
 613 0232 07F18043 		add	r3, r7, #1073741824
 614 0236 0133     		adds	r3, r3, #1
 615              		.loc 1 259 36 view .LVU196
 616 0238 2A6A     		ldr	r2, [r5, #32]
 617              		.loc 1 259 29 view .LVU197
 618 023a 40F82320 		str	r2, [r0, r3, lsl #2]
 256:main.c        **** 
 619              		.loc 1 256 25 view .LVU198
 620 023e 0646     		mov	r6, r0
 256:main.c        **** 
 621              		.loc 1 256 17 view .LVU199
 622 0240 6060     		str	r0, [r4, #4]
 258:main.c        ****     layer_sizes[n_layers-1] = param->output_layer_size;
 623              		.loc 1 258 5 is_stmt 1 view .LVU200
 624              		.loc 1 259 5 view .LVU201
 260:main.c        **** 
 261:main.c        ****     for (i = 1; i < n_layers-1 ; i++)
 625              		.loc 1 261 5 view .LVU202
 626              	.LVL62:
 627              		.loc 1 261 12 is_stmt 0 view .LVU203
 628 0242 0123     		movs	r3, #1
 629              	.LVL63:
 630              	.L24:
 631              		.loc 1 261 17 is_stmt 1 discriminator 1 view .LVU204
 632              		.loc 1 261 5 is_stmt 0 discriminator 1 view .LVU205
 633 0244 9F42     		cmp	r7, r3
 634 0246 22DA     		bge	.L25
 262:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 263:main.c        **** 
 264:main.c        ****     // Create memory for the weight matrices between layers
 265:main.c        ****     // weight is a pointer to the array of 2D arrays between the layers
 266:main.c        ****     param->weight = (double***)calloc(n_layers - 1, sizeof(double**));
 635              		.loc 1 266 5 is_stmt 1 view .LVU206
 636              		.loc 1 266 32 is_stmt 0 view .LVU207
 637 0248 0421     		movs	r1, #4
 638 024a 781C     		adds	r0, r7, #1
 639 024c FFF7FEFF 		bl	calloc
 640              	.LVL64:
 267:main.c        **** 
 268:main.c        ****     // Each 2D array between two layers i and i+1 is of size ((layer_size[i]+1) x layer_size[i+1])
 269:main.c        ****     // The weight matrix includes weights for the bias terms too
 270:main.c        ****     for (i = 0; i < n_layers-1; i++)
 641              		.loc 1 270 12 view .LVU208
 642 0250 4FF00009 		mov	r9, #0
 266:main.c        **** 
 643              		.loc 1 266 32 view .LVU209
 644 0254 8046     		mov	r8, r0
 266:main.c        **** 
 645              		.loc 1 266 19 view .LVU210
 646 0256 E863     		str	r0, [r5, #60]
 647              		.loc 1 270 5 is_stmt 1 view .LVU211
 648              	.LVL65:
 649              	.L26:
 650              		.loc 1 270 17 discriminator 1 view .LVU212
 651              		.loc 1 270 5 is_stmt 0 discriminator 1 view .LVU213
 652 0258 4F45     		cmp	r7, r9
 653 025a 21DA     		bge	.L27
 654 025c B146     		mov	r9, r6
 655              	.LVL66:
 656              		.loc 1 270 5 view .LVU214
 657 025e B346     		mov	fp, r6
 271:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 272:main.c        **** 
 273:main.c        ****     int j;
 274:main.c        ****     for (i = 0; i < n_layers-1; i++)
 658              		.loc 1 274 12 view .LVU215
 659 0260 4FF0000A 		mov	r10, #0
 660              	.L28:
 661              	.LVL67:
 662              		.loc 1 274 17 is_stmt 1 discriminator 1 view .LVU216
 663              		.loc 1 274 5 is_stmt 0 discriminator 1 view .LVU217
 664 0264 5745     		cmp	r7, r10
 665 0266 62DA     		bge	.L46
 275:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 276:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 277:main.c        **** 
 278:main.c        ****     double weights[] = {
 666              		.loc 1 278 5 is_stmt 1 view .LVU218
 667              		.loc 1 278 12 is_stmt 0 view .LVU219
 668 0268 0DF58C7A 		add	r10, sp, #280
 669              	.LVL68:
 670              		.loc 1 278 12 view .LVU220
 671 026c 2349     		ldr	r1, .L53+68
 672 026e 4FF42A72 		mov	r2, #680
 673 0272 5046     		mov	r0, r10
 674 0274 FFF7FEFF 		bl	memcpy
 675              	.LVL69:
 279:main.c        ****     0.725865, 0.441536, -0.799100, 0.009719, 0.445643, -0.595062, -0.250179, 0.208894, 0.276722, 0.
 280:main.c        ****     0.011293, 0.240472, 0.452365, 0.149054, -0.471252, 0.584530, -0.208878, -0.344829, 0.160482, 0.
 281:main.c        ****     -0.797066, -0.544316, 0.332514, -0.195160, -0.127443, 0.405487, -0.276599, -0.739743, 0.706677,
 282:main.c        ****     0.661625, -0.322602, -0.528113, -0.431437, -0.429017, -0.452627, -0.327129, -0.325360, 0.160116
 283:main.c        ****     0.099907, -0.994370, 0.701389, -0.158393, -0.674160
 284:main.c        ****     };
 285:main.c        **** 
 286:main.c        ****     int weightIndex = 0;
 676              		.loc 1 286 5 is_stmt 1 view .LVU221
 287:main.c        ****     for (int i = 0; i < n_layers - 1; i++) {
 677              		.loc 1 287 5 view .LVU222
 678              	.LBB5:
 679              		.loc 1 287 10 view .LVU223
 680              		.loc 1 287 14 is_stmt 0 view .LVU224
 681 0278 0023     		movs	r3, #0
 682              	.LBE5:
 286:main.c        ****     for (int i = 0; i < n_layers - 1; i++) {
 683              		.loc 1 286 9 view .LVU225
 684 027a 9C46     		mov	ip, r3
 685 027c CDF80CA0 		str	r10, [sp, #12]
 686              	.LVL70:
 687              	.L31:
 688              	.LBB10:
 689              		.loc 1 287 21 is_stmt 1 discriminator 1 view .LVU226
 690              		.loc 1 287 5 is_stmt 0 discriminator 1 view .LVU227
 691 0280 9F42     		cmp	r7, r3
 692 0282 7ADB     		blt	.L35
 693              	.LBB6:
 288:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 694              		.loc 1 288 27 view .LVU228
 695 0284 59F8042B 		ldr	r2, [r9], #4
 696 0288 0292     		str	r2, [sp, #8]
 697              		.loc 1 288 18 view .LVU229
 698 028a 0022     		movs	r2, #0
 699 028c 65E0     		b	.L36
 700              	.LVL71:
 701              	.L25:
 702              		.loc 1 288 18 view .LVU230
 703              	.LBE6:
 704              	.LBE10:
 262:main.c        **** 
 705              		.loc 1 262 9 is_stmt 1 discriminator 3 view .LVU231
 262:main.c        **** 
 706              		.loc 1 262 51 is_stmt 0 discriminator 3 view .LVU232
 707 028e 6A68     		ldr	r2, [r5, #4]
 708 0290 02EB8302 		add	r2, r2, r3, lsl #2
 709 0294 52F8042C 		ldr	r2, [r2, #-4]
 262:main.c        **** 
 710              		.loc 1 262 24 discriminator 3 view .LVU233
 711 0298 46F82320 		str	r2, [r6, r3, lsl #2]
 261:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 712              		.loc 1 261 34 is_stmt 1 discriminator 3 view .LVU234
 261:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 713              		.loc 1 261 35 is_stmt 0 discriminator 3 view .LVU235
 714 029c 0133     		adds	r3, r3, #1
 715              	.LVL72:
 261:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 716              		.loc 1 261 35 discriminator 3 view .LVU236
 717 029e D1E7     		b	.L24
 718              	.LVL73:
 719              	.L27:
 271:main.c        **** 
 720              		.loc 1 271 9 is_stmt 1 discriminator 3 view .LVU237
 271:main.c        **** 
 721              		.loc 1 271 59 is_stmt 0 discriminator 3 view .LVU238
 722 02a0 56F82900 		ldr	r0, [r6, r9, lsl #2]
 271:main.c        **** 
 723              		.loc 1 271 38 discriminator 3 view .LVU239
 724 02a4 0421     		movs	r1, #4
 725 02a6 0130     		adds	r0, r0, #1
 726 02a8 FFF7FEFF 		bl	calloc
 727              	.LVL74:
 271:main.c        **** 
 728              		.loc 1 271 26 discriminator 3 view .LVU240
 729 02ac 48F82900 		str	r0, [r8, r9, lsl #2]
 270:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 730              		.loc 1 270 33 is_stmt 1 discriminator 3 view .LVU241
 270:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 731              		.loc 1 270 34 is_stmt 0 discriminator 3 view .LVU242
 732 02b0 09F10109 		add	r9, r9, #1
 733              	.LVL75:
 270:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 734              		.loc 1 270 34 discriminator 3 view .LVU243
 735 02b4 D0E7     		b	.L26
 736              	.L54:
 737 02b6 00BF     		.align	2
 738              	.L53:
 739 02b8 00000000 		.word	.LANCHOR0
 740 02bc 00000000 		.word	.LANCHOR1
 741 02c0 72000000 		.word	.LC17
 742 02c4 A0000000 		.word	.LC18
 743 02c8 2C000000 		.word	.LC5
 744 02cc D8000000 		.word	.LC21
 745 02d0 79010000 		.word	.LC26
 746 02d4 A2000000 		.word	.LC19
 747 02d8 CF000000 		.word	.LC20
 748 02dc DD000000 		.word	.LC22
 749 02e0 E2000000 		.word	.LC23
 750 02e4 EA000000 		.word	.LC24
 751 02e8 1E010000 		.word	.LC25
 752 02ec 2D020000 		.word	.LC29
 753 02f0 9E010000 		.word	.LC27
 754 02f4 D2010000 		.word	.LC28
 755 02f8 40000000 		.word	.LANCHOR0+64
 756 02fc 08010000 		.word	.LANCHOR0+264
 757              	.LVL76:
 758              	.L29:
 276:main.c        **** 
 759              		.loc 1 276 29 discriminator 3 view .LVU244
 760 0300 58F82A20 		ldr	r2, [r8, r10, lsl #2]
 276:main.c        **** 
 761              		.loc 1 276 44 discriminator 3 view .LVU245
 762 0304 DBF80400 		ldr	r0, [fp, #4]
 763 0308 0193     		str	r3, [sp, #4]
 276:main.c        **** 
 764              		.loc 1 276 13 is_stmt 1 discriminator 3 view .LVU246
 276:main.c        **** 
 765              		.loc 1 276 44 is_stmt 0 discriminator 3 view .LVU247
 766 030a 0821     		movs	r1, #8
 276:main.c        **** 
 767              		.loc 1 276 29 discriminator 3 view .LVU248
 768 030c 0092     		str	r2, [sp]
 276:main.c        **** 
 769              		.loc 1 276 44 discriminator 3 view .LVU249
 770 030e FFF7FEFF 		bl	calloc
 771              	.LVL77:
 276:main.c        **** 
 772              		.loc 1 276 33 discriminator 3 view .LVU250
 773 0312 DDE90023 		ldrd	r2, r3, [sp]
 774 0316 42F82300 		str	r0, [r2, r3, lsl #2]
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 775              		.loc 1 275 43 is_stmt 1 discriminator 3 view .LVU251
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 776              		.loc 1 275 44 is_stmt 0 discriminator 3 view .LVU252
 777 031a 0133     		adds	r3, r3, #1
 778              	.LVL78:
 779              	.L30:
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 780              		.loc 1 275 21 is_stmt 1 discriminator 1 view .LVU253
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 781              		.loc 1 275 9 is_stmt 0 discriminator 1 view .LVU254
 782 031c DBF80020 		ldr	r2, [fp]
 783 0320 9A42     		cmp	r2, r3
 784 0322 EDDA     		bge	.L29
 274:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 785              		.loc 1 274 33 is_stmt 1 discriminator 2 view .LVU255
 274:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 786              		.loc 1 274 34 is_stmt 0 discriminator 2 view .LVU256
 787 0324 0AF1010A 		add	r10, r10, #1
 788              	.LVL79:
 274:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 789              		.loc 1 274 34 discriminator 2 view .LVU257
 790 0328 0BF1040B 		add	fp, fp, #4
 791 032c 9AE7     		b	.L28
 792              	.LVL80:
 793              	.L46:
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 794              		.loc 1 275 16 view .LVU258
 795 032e 0023     		movs	r3, #0
 796 0330 F4E7     		b	.L30
 797              	.LVL81:
 798              	.L32:
 799              	.LBB11:
 800              	.LBB9:
 801              	.LBB7:
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 290:main.c        ****                 param->weight[i][j][k] = weights[weightIndex++];
 802              		.loc 1 290 17 is_stmt 1 discriminator 3 view .LVU259
 803              		.loc 1 290 49 is_stmt 0 discriminator 3 view .LVU260
 804 0332 0199     		ldr	r1, [sp, #4]
 805 0334 F1E802AB 		ldrd	r10, [r1], #8
 806 0338 0191     		str	r1, [sp, #4]
 807              		.loc 1 290 33 discriminator 3 view .LVU261
 808 033a 58F82310 		ldr	r1, [r8, r3, lsl #2]
 809              		.loc 1 290 40 discriminator 3 view .LVU262
 810 033e 51F80E10 		ldr	r1, [r1, lr]
 811 0342 01EBC001 		add	r1, r1, r0, lsl #3
 812 0346 C1E900AB 		strd	r10, [r1]
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 813              		.loc 1 289 53 is_stmt 1 discriminator 3 view .LVU263
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 814              		.loc 1 289 54 is_stmt 0 discriminator 3 view .LVU264
 815 034a 0130     		adds	r0, r0, #1
 816              	.LVL82:
 817              	.L34:
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 818              		.loc 1 289 29 is_stmt 1 discriminator 1 view .LVU265
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 819              		.loc 1 289 13 is_stmt 0 discriminator 1 view .LVU266
 820 034c 0099     		ldr	r1, [sp]
 821 034e 8142     		cmp	r1, r0
 822 0350 EFDC     		bgt	.L32
 823 0352 0029     		cmp	r1, #0
 824 0354 A8BF     		it	ge
 825 0356 8C44     		addge	ip, ip, r1
 826              	.LBE7:
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 827              		.loc 1 288 49 is_stmt 1 discriminator 2 view .LVU267
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 828              		.loc 1 288 50 is_stmt 0 discriminator 2 view .LVU268
 829 0358 0132     		adds	r2, r2, #1
 830              	.LVL83:
 831              	.L36:
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 832              		.loc 1 288 25 is_stmt 1 discriminator 1 view .LVU269
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 833              		.loc 1 288 9 is_stmt 0 discriminator 1 view .LVU270
 834 035a 0299     		ldr	r1, [sp, #8]
 835 035c 9142     		cmp	r1, r2
 836 035e 0ADB     		blt	.L33
 837              	.LBB8:
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 838              		.loc 1 289 44 view .LVU271
 839 0360 D9F80010 		ldr	r1, [r9]
 840 0364 0091     		str	r1, [sp]
 841 0366 9100     		lsls	r1, r2, #2
 842 0368 8E46     		mov	lr, r1
 843 036a 0399     		ldr	r1, [sp, #12]
 844 036c 01EBCC01 		add	r1, r1, ip, lsl #3
 845 0370 0191     		str	r1, [sp, #4]
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 846              		.loc 1 289 22 view .LVU272
 847 0372 0020     		movs	r0, #0
 848 0374 EAE7     		b	.L34
 849              	.L33:
 850              	.LBE8:
 851              	.LBE9:
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 852              		.loc 1 287 39 is_stmt 1 discriminator 2 view .LVU273
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 853              		.loc 1 287 40 is_stmt 0 discriminator 2 view .LVU274
 854 0376 0133     		adds	r3, r3, #1
 855              	.LVL84:
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 856              		.loc 1 287 40 discriminator 2 view .LVU275
 857 0378 82E7     		b	.L31
 858              	.LVL85:
 859              	.L35:
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 860              		.loc 1 287 40 discriminator 2 view .LVU276
 861              	.LBE11:
 291:main.c        ****             }
 292:main.c        ****         }
 293:main.c        ****     }
 294:main.c        **** 
 295:main.c        ****     // Train the neural network on the train data
 296:main.c        ****     // printf("Training:\n");
 297:main.c        ****     // printf("---------\n");
 298:main.c        ****     // mlp_trainer(param, layer_sizes);
 299:main.c        ****     // printf("\nDone.\n\n");
 300:main.c        **** 
 301:main.c        ****     //save the trained weights to a file
 302:main.c        ****     // FILE *fp = fopen("weights.txt", "w");
 303:main.c        ****     // for (i = 0; i < n_layers-1; i++) {
 304:main.c        ****     //     for (j = 0; j < layer_sizes[i]+1; j++) {
 305:main.c        ****     //         for (int k = 0; k < layer_sizes[i+1]; k++) {
 306:main.c        ****     //             fprintf(fp, "%lf ", param->weight[i][j][k]);
 307:main.c        ****     //         }
 308:main.c        ****     //         fprintf(fp, "\n");
 309:main.c        ****     //     }
 310:main.c        ****     //     fprintf(fp, "\n");
 311:main.c        ****     // }
 312:main.c        ****     // fclose(fp);
 313:main.c        **** 
 314:main.c        ****     // Classify the test data using the trained parameter weights
 315:main.c        ****     //printf("Classifying:\n");
 316:main.c        ****     //printf("------------\n");
 317:main.c        ****     mlp_classifier(param, layer_sizes);
 862              		.loc 1 317 5 is_stmt 1 view .LVU277
 863 037a 3146     		mov	r1, r6
 864 037c 2846     		mov	r0, r5
 865 037e FFF7FEFF 		bl	mlp_classifier
 866              	.LVL86:
 318:main.c        ****     //while(1)
 319:main.c        ****         //simpleserial_get();
 320:main.c        ****     //printf("\nDone.\nOutput file generated\n");
 321:main.c        **** 
 322:main.c        ****     // Free the memory allocated in Heap
 323:main.c        ****     for (i = 0; i < n_layers-1; i++)
 867              		.loc 1 323 5 view .LVU278
 868              		.loc 1 323 12 is_stmt 0 view .LVU279
 869 0382 0026     		movs	r6, #0
 870              	.LVL87:
 871              	.L37:
 872              		.loc 1 323 17 is_stmt 1 discriminator 1 view .LVU280
 873              		.loc 1 323 5 is_stmt 0 discriminator 1 view .LVU281
 874 0384 B742     		cmp	r7, r6
 875 0386 42DB     		blt	.L47
 876 0388 4FEA8608 		lsl	r8, r6, #2
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 877              		.loc 1 324 16 view .LVU282
 878 038c 0025     		movs	r5, #0
 879 038e 06E0     		b	.L40
 880              	.LVL88:
 881              	.L38:
 325:main.c        ****             free(param->weight[i][j]);
 882              		.loc 1 325 13 is_stmt 1 discriminator 3 view .LVU283
 883 0390 52F80830 		ldr	r3, [r2, r8]
 884 0394 53F82500 		ldr	r0, [r3, r5, lsl #2]
 885 0398 FFF7FEFF 		bl	free
 886              	.LVL89:
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 887              		.loc 1 324 43 discriminator 3 view .LVU284
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 888              		.loc 1 324 44 is_stmt 0 discriminator 3 view .LVU285
 889 039c 0135     		adds	r5, r5, #1
 890              	.LVL90:
 891              	.L40:
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 892              		.loc 1 324 21 is_stmt 1 discriminator 1 view .LVU286
 893              		.loc 1 325 23 is_stmt 0 discriminator 1 view .LVU287
 894 039e 2368     		ldr	r3, [r4]
 895 03a0 DA6B     		ldr	r2, [r3, #60]
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 896              		.loc 1 324 23 discriminator 1 view .LVU288
 897 03a2 6368     		ldr	r3, [r4, #4]
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 898              		.loc 1 324 9 discriminator 1 view .LVU289
 899 03a4 53F80830 		ldr	r3, [r3, r8]
 900 03a8 AB42     		cmp	r3, r5
 901 03aa F1DA     		bge	.L38
 323:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 902              		.loc 1 323 33 is_stmt 1 discriminator 2 view .LVU290
 323:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 903              		.loc 1 323 34 is_stmt 0 discriminator 2 view .LVU291
 904 03ac 0136     		adds	r6, r6, #1
 905              	.LVL91:
 323:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 906              		.loc 1 323 34 discriminator 2 view .LVU292
 907 03ae E9E7     		b	.L37
 908              	.LVL92:
 909              	.L41:
 326:main.c        **** 
 327:main.c        ****     for (i = 0; i < n_layers-1; i++)
 328:main.c        ****         free(param->weight[i]);
 910              		.loc 1 328 9 is_stmt 1 discriminator 3 view .LVU293
 911 03b0 50F82500 		ldr	r0, [r0, r5, lsl #2]
 912 03b4 FFF7FEFF 		bl	free
 913              	.LVL93:
 327:main.c        ****         free(param->weight[i]);
 914              		.loc 1 327 33 discriminator 3 view .LVU294
 327:main.c        ****         free(param->weight[i]);
 915              		.loc 1 327 34 is_stmt 0 discriminator 3 view .LVU295
 916 03b8 0135     		adds	r5, r5, #1
 917              	.LVL94:
 918              	.L39:
 327:main.c        ****         free(param->weight[i]);
 919              		.loc 1 327 17 is_stmt 1 discriminator 1 view .LVU296
 920              		.loc 1 328 19 is_stmt 0 discriminator 1 view .LVU297
 921 03ba 2368     		ldr	r3, [r4]
 327:main.c        ****         free(param->weight[i]);
 922              		.loc 1 327 5 discriminator 1 view .LVU298
 923 03bc AF42     		cmp	r7, r5
 924              		.loc 1 328 19 discriminator 1 view .LVU299
 925 03be D86B     		ldr	r0, [r3, #60]
 327:main.c        ****         free(param->weight[i]);
 926              		.loc 1 327 5 discriminator 1 view .LVU300
 927 03c0 F6DA     		bge	.L41
 329:main.c        **** 
 330:main.c        ****     free(param->weight);
 928              		.loc 1 330 5 is_stmt 1 view .LVU301
 929 03c2 FFF7FEFF 		bl	free
 930              	.LVL95:
 331:main.c        **** 
 332:main.c        ****     free(layer_sizes);
 931              		.loc 1 332 5 view .LVU302
 932 03c6 6068     		ldr	r0, [r4, #4]
 933 03c8 FFF7FEFF 		bl	free
 934              	.LVL96:
 333:main.c        **** 
 334:main.c        ****     for (i = 0; i < param->train_sample_size; i++)
 935              		.loc 1 334 5 view .LVU303
 936              		.loc 1 334 12 is_stmt 0 view .LVU304
 937 03cc 0025     		movs	r5, #0
 938              	.LVL97:
 939              	.L42:
 940              		.loc 1 334 17 is_stmt 1 discriminator 1 view .LVU305
 941              		.loc 1 334 26 is_stmt 0 discriminator 1 view .LVU306
 942 03ce 2368     		ldr	r3, [r4]
 943              		.loc 1 334 5 discriminator 1 view .LVU307
 944 03d0 5A6B     		ldr	r2, [r3, #52]
 945 03d2 AA42     		cmp	r2, r5
 946 03d4 1DDC     		bgt	.L43
 335:main.c        ****         free(param->data_train[i]);
 336:main.c        **** 
 337:main.c        ****     for (i = 0; i < param->test_sample_size; i++)
 947              		.loc 1 337 12 view .LVU308
 948 03d6 0025     		movs	r5, #0
 949              	.LVL98:
 950              	.L44:
 951              		.loc 1 337 17 is_stmt 1 discriminator 1 view .LVU309
 952              		.loc 1 337 26 is_stmt 0 discriminator 1 view .LVU310
 953 03d8 2368     		ldr	r3, [r4]
 954              		.loc 1 337 5 discriminator 1 view .LVU311
 955 03da 9A6B     		ldr	r2, [r3, #56]
 956 03dc AA42     		cmp	r2, r5
 957 03de 1FDC     		bgt	.L45
 338:main.c        ****         free(param->data_test[i]);
 339:main.c        **** 
 340:main.c        ****     free(param->data_train);
 958              		.loc 1 340 5 is_stmt 1 view .LVU312
 959 03e0 986A     		ldr	r0, [r3, #40]
 960 03e2 FFF7FEFF 		bl	free
 961              	.LVL99:
 341:main.c        ****     free(param->data_test);
 962              		.loc 1 341 5 view .LVU313
 963              		.loc 1 341 15 is_stmt 0 view .LVU314
 964 03e6 2368     		ldr	r3, [r4]
 965              		.loc 1 341 5 view .LVU315
 966 03e8 D86A     		ldr	r0, [r3, #44]
 967 03ea FFF7FEFF 		bl	free
 968              	.LVL100:
 342:main.c        ****     free(param->hidden_activation_functions);
 969              		.loc 1 342 5 is_stmt 1 view .LVU316
 970              		.loc 1 342 15 is_stmt 0 view .LVU317
 971 03ee 2368     		ldr	r3, [r4]
 972              		.loc 1 342 5 view .LVU318
 973 03f0 9868     		ldr	r0, [r3, #8]
 974 03f2 FFF7FEFF 		bl	free
 975              	.LVL101:
 343:main.c        ****     free(param->hidden_layers_size);
 976              		.loc 1 343 5 is_stmt 1 view .LVU319
 977              		.loc 1 343 15 is_stmt 0 view .LVU320
 978 03f6 2368     		ldr	r3, [r4]
 979              		.loc 1 343 5 view .LVU321
 980 03f8 5868     		ldr	r0, [r3, #4]
 981 03fa FFF7FEFF 		bl	free
 982              	.LVL102:
 344:main.c        ****     free(param);
 983              		.loc 1 344 5 is_stmt 1 view .LVU322
 984 03fe 2068     		ldr	r0, [r4]
 985 0400 FFF7FEFF 		bl	free
 986              	.LVL103:
 345:main.c        **** 
 346:main.c        ****     return 0x00;
 987              		.loc 1 346 5 view .LVU323
 347:main.c        **** }
 988              		.loc 1 347 1 is_stmt 0 view .LVU324
 989 0404 0020     		movs	r0, #0
 990 0406 0DF5717D 		add	sp, sp, #964
 991              	.LCFI2:
 992              		.cfi_remember_state
 993              		.cfi_def_cfa_offset 36
 994              		@ sp needed
 995 040a BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 996              	.LVL104:
 997              	.L47:
 998              	.LCFI3:
 999              		.cfi_restore_state
 327:main.c        ****         free(param->weight[i]);
 1000              		.loc 1 327 12 view .LVU325
 1001 040e 0025     		movs	r5, #0
 1002 0410 D3E7     		b	.L39
 1003              	.LVL105:
 1004              	.L43:
 335:main.c        **** 
 1005              		.loc 1 335 9 is_stmt 1 discriminator 3 view .LVU326
 1006 0412 9B6A     		ldr	r3, [r3, #40]
 1007 0414 53F82500 		ldr	r0, [r3, r5, lsl #2]
 1008 0418 FFF7FEFF 		bl	free
 1009              	.LVL106:
 334:main.c        ****         free(param->data_train[i]);
 1010              		.loc 1 334 47 discriminator 3 view .LVU327
 334:main.c        ****         free(param->data_train[i]);
 1011              		.loc 1 334 48 is_stmt 0 discriminator 3 view .LVU328
 1012 041c 0135     		adds	r5, r5, #1
 1013              	.LVL107:
 334:main.c        ****         free(param->data_train[i]);
 1014              		.loc 1 334 48 discriminator 3 view .LVU329
 1015 041e D6E7     		b	.L42
 1016              	.L45:
 338:main.c        **** 
 1017              		.loc 1 338 9 is_stmt 1 discriminator 3 view .LVU330
 1018 0420 DB6A     		ldr	r3, [r3, #44]
 1019 0422 53F82500 		ldr	r0, [r3, r5, lsl #2]
 1020 0426 FFF7FEFF 		bl	free
 1021              	.LVL108:
 337:main.c        ****         free(param->data_test[i]);
 1022              		.loc 1 337 46 discriminator 3 view .LVU331
 337:main.c        ****         free(param->data_test[i]);
 1023              		.loc 1 337 47 is_stmt 0 discriminator 3 view .LVU332
 1024 042a 0135     		adds	r5, r5, #1
 1025              	.LVL109:
 337:main.c        ****         free(param->data_test[i]);
 1026              		.loc 1 337 47 discriminator 3 view .LVU333
 1027 042c D4E7     		b	.L44
 1028              		.cfi_endproc
 1029              	.LFE3:
 1031 042e 00BF     		.section	.text.startup.main,"ax",%progbits
 1032              		.align	1
 1033              		.global	main
 1034              		.syntax unified
 1035              		.thumb
 1036              		.thumb_func
 1037              		.fpu softvfp
 1039              	main:
 1040              	.LFB4:
 348:main.c        **** 
 349:main.c        **** int main(void) {
 1041              		.loc 1 349 16 is_stmt 1 view -0
 1042              		.cfi_startproc
 1043              		@ Volatile: function does not return.
 1044              		@ args = 0, pretend = 0, frame = 8
 1045              		@ frame_needed = 0, uses_anonymous_args = 0
 350:main.c        ****     // Initialize UART for serial communication
 351:main.c        ****     platform_init();
 1046              		.loc 1 351 5 view .LVU335
 349:main.c        ****     // Initialize UART for serial communication
 1047              		.loc 1 349 16 is_stmt 0 view .LVU336
 1048 0000 07B5     		push	{r0, r1, r2, lr}
 1049              	.LCFI4:
 1050              		.cfi_def_cfa_offset 16
 1051              		.cfi_offset 14, -4
 1052              		.loc 1 351 5 view .LVU337
 1053 0002 FFF7FEFF 		bl	platform_init
 1054              	.LVL110:
 352:main.c        ****     init_uart();
 1055              		.loc 1 352 5 is_stmt 1 view .LVU338
 1056 0006 FFF7FEFF 		bl	init_uart
 1057              	.LVL111:
 353:main.c        ****     trigger_setup();
 1058              		.loc 1 353 5 view .LVU339
 1059 000a FFF7FEFF 		bl	trigger_setup
 1060              	.LVL112:
 354:main.c        ****     simpleserial_init();
 1061              		.loc 1 354 5 view .LVU340
 1062 000e FFF7FEFF 		bl	simpleserial_init
 1063              	.LVL113:
 355:main.c        **** 
 356:main.c        ****     // Add a command to the SimpleSerial module
 357:main.c        ****     simpleserial_addcmd('a', 0, mlp);
 1064              		.loc 1 357 5 view .LVU341
 1065 0012 084A     		ldr	r2, .L57
 1066 0014 0021     		movs	r1, #0
 1067 0016 6120     		movs	r0, #97
 1068 0018 FFF7FEFF 		bl	simpleserial_addcmd
 1069              	.LVL114:
 358:main.c        ****     //put some value so we can verify if we cna read them.
 359:main.c        **** 
 360:main.c        ****     uint8_t test;
 1070              		.loc 1 360 5 view .LVU342
 361:main.c        ****     test = 42;
 1071              		.loc 1 361 5 view .LVU343
 1072              		.loc 1 361 10 is_stmt 0 view .LVU344
 1073 001c 2A23     		movs	r3, #42
 362:main.c        ****     simpleserial_put('r', 1, (uint8_t*)&test);
 1074              		.loc 1 362 5 view .LVU345
 1075 001e 0DF10702 		add	r2, sp, #7
 1076 0022 0121     		movs	r1, #1
 1077 0024 7220     		movs	r0, #114
 361:main.c        ****     test = 42;
 1078              		.loc 1 361 10 view .LVU346
 1079 0026 8DF80730 		strb	r3, [sp, #7]
 1080              		.loc 1 362 5 is_stmt 1 view .LVU347
 1081 002a FFF7FEFF 		bl	simpleserial_put
 1082              	.LVL115:
 1083              	.L56:
 363:main.c        ****     while (1){
 1084              		.loc 1 363 5 discriminator 1 view .LVU348
 364:main.c        ****         simpleserial_get();
 1085              		.loc 1 364 9 discriminator 1 view .LVU349
 1086 002e FFF7FEFF 		bl	simpleserial_get
 1087              	.LVL116:
 363:main.c        ****     while (1){
 1088              		.loc 1 363 11 discriminator 1 view .LVU350
 1089 0032 FCE7     		b	.L56
 1090              	.L58:
 1091              		.align	2
 1092              	.L57:
 1093 0034 00000000 		.word	mlp
 1094              		.cfi_endproc
 1095              	.LFE4:
 1097              		.global	layer_sizes
 1098              		.global	param
 1099              		.section	.rodata
 1100              		.align	3
 1101              		.set	.LANCHOR0,. + 0
 1102              	.LC16:
 1103 0000 00000000 		.word	.LC0
 1104 0004 10000000 		.word	.LC1
 1105 0008 12000000 		.word	.LC2
 1106 000c 18000000 		.word	.LC3
 1107 0010 2A000000 		.word	.LC4
 1108 0014 2C000000 		.word	.LC5
 1109 0018 34000000 		.word	.LC6
 1110 001c 39000000 		.word	.LC7
 1111 0020 40000000 		.word	.LC8
 1112 0024 54000000 		.word	.LC9
 1113 0028 59000000 		.word	.LC10
 1114 002c 5B000000 		.word	.LC11
 1115 0030 6E000000 		.word	.LC12
 1116 0034 59000000 		.word	.LC10
 1117 0038 00000000 		.word	0
 1118 003c 00000000 		.space	4
 1119              	.LC14:
 1120 0040 6F1283C0 		.word	-1065151889
 1121 0044 CAA1F93F 		.word	1073324490
 1122 0048 1CEBE236 		.word	920840988
 1123 004c 1A801840 		.word	1075347482
 1124 0050 728577B9 		.word	-1183349390
 1125 0054 88EFE03F 		.word	1071705992
 1126 0058 3134D769 		.word	1775711281
 1127 005c A4A5DE3F 		.word	1071556004
 1128 0060 00000000 		.word	0
 1129 0064 00000000 		.word	0
 1130 0068 4BC8073D 		.word	1023920203
 1131 006c 9B5502C0 		.word	-1073588837
 1132 0070 BC490C02 		.word	34359740
 1133 0074 2B071DC0 		.word	-1071839445
 1134 0078 82E2C798 		.word	-1731730814
 1135 007c BBD61F40 		.word	1075828411
 1136 0080 280F0BB5 		.word	-1257566424
 1137 0084 A679ED3F 		.word	1072527782
 1138 0088 00000000 		.word	0
 1139 008c 0000F03F 		.word	1072693248
 1140 0090 5F6397A8 		.word	-1466473633
 1141 0094 DE1AE6BF 		.word	-1075438882
 1142 0098 662C9ACE 		.word	-828756890
 1143 009c 4E06E0BF 		.word	-1075837362
 1144 00a0 425BCEA5 		.word	-1513202878
 1145 00a4 B8AAD6BF 		.word	-1076450632
 1146 00a8 D9429083 		.word	-2087697703
 1147 00ac 1266DE3F 		.word	1071539730
 1148 00b0 00000000 		.word	0
 1149 00b4 0000F03F 		.word	1072693248
 1150 00b8 C66D3480 		.word	-2144047674
 1151 00bc B740FA3F 		.word	1073365175
 1152 00c0 55C1A8A4 		.word	-1532444331
 1153 00c4 4E001140 		.word	1074856014
 1154 00c8 24B9FC87 		.word	-2013480668
 1155 00cc F49B13C0 		.word	-1072456716
 1156 00d0 EB73B515 		.word	364213227
 1157 00d4 FB4B05C0 		.word	-1073394693
 1158 00d8 00000000 		.word	0
 1159 00dc 0000F03F 		.word	1072693248
 1160 00e0 04560E2D 		.word	755914244
 1161 00e4 B29D0C40 		.word	1074568626
 1162 00e8 158C4AEA 		.word	-364213227
 1163 00ec 04340340 		.word	1073951748
 1164 00f0 C66D3480 		.word	-2144047674
 1165 00f4 B740FE3F 		.word	1073627319
 1166 00f8 90149161 		.word	1636897936
 1167 00fc 156FE73F 		.word	1072131861
 1168 0100 00000000 		.word	0
 1169 0104 00000000 		.word	0
 1170              	.LC15:
 1171 0108 0AF4893C 		.word	1015673866
 1172 010c 493AE73F 		.word	1072118345
 1173 0110 0D6D0036 		.word	905997581
 1174 0114 2042DC3F 		.word	1071399456
 1175 0118 A779C729 		.word	700938663
 1176 011c 3A92E9BF 		.word	-1075211718
 1177 0120 EDD63219 		.word	422762221
 1178 0124 8EE7833F 		.word	1065609102
 1179 0128 B83EAC37 		.word	934035128
 1180 012c 6A85DC3F 		.word	1071416682
 1181 0130 8CF4A276 		.word	1990390924
 1182 0134 BF0AE3BF 		.word	-1075639617
 1183 0138 CD57C9C7 		.word	-943106099
 1184 013c EE02D0BF 		.word	-1076886802
 1185 0140 E3512AE1 		.word	-517320221
 1186 0144 09BDCA3F 		.word	1070251273
 1187 0148 8A5B0531 		.word	822434698
 1188 014c D0B5D13F 		.word	1070708176
 1189 0150 88467710 		.word	276252296
 1190 0154 3B53C83F 		.word	1070093115
 1191 0158 1A14CD03 		.word	63771674
 1192 015c 58E4A7BF 		.word	-1079516072
 1193 0160 09F9A067 		.word	1738602761
 1194 0164 B36AE83F 		.word	1072196275
 1195 0168 310A82C7 		.word	-947779023
 1196 016c B777CBBF 		.word	-1077184585
 1197 0170 CC96AC8A 		.word	-1968400692
 1198 0174 7093D9BF 		.word	-1076259984
 1199 0178 B950F9D7 		.word	-671526727
 1200 017c F2CAE7BF 		.word	-1075328270
 1201 0180 9544F641 		.word	1106658453
 1202 0184 9685E73F 		.word	1072137622
 1203 0188 8EACFC32 		.word	855420046
 1204 018c 1823CA3F 		.word	1070211864
 1205 0190 AAD72D02 		.word	36558762
 1206 0194 637DE0BF 		.word	-1075806877
 1207 0198 8AE942AC 		.word	-1404900982
 1208 019c FE88E43F 		.word	1071941886
 1209 01a0 F8E28BF6 		.word	-158604552
 1210 01a4 7821D1BF 		.word	-1076813448
 1211 01a8 81CB63CD 		.word	-849097855
 1212 01ac C820873F 		.word	1065820360
 1213 01b0 6F46CD57 		.word	1473070703
 1214 01b4 C9C7CE3F 		.word	1070516169
 1215 01b8 FAB83654 		.word	1412872442
 1216 01bc 8CF3DC3F 		.word	1071444876
 1217 01c0 0F43AB93 		.word	-1817492721
 1218 01c4 3314C33F 		.word	1069749299
 1219 01c8 842C0B26 		.word	638266500
 1220 01cc FE28DEBF 		.word	-1075959554
 1221 01d0 F8FC3042 		.word	1110506744
 1222 01d4 78B4E23F 		.word	1071821944
 1223 01d8 344C6DA9 		.word	-1452454860
 1224 01dc 83BCCABF 		.word	-1077232509
 1225 01e0 B3976DA7 		.word	-1485989965
 1226 01e4 AD11D6BF 		.word	-1076489811
 1227 01e8 C05FCC96 		.word	-1764991040
 1228 01ec AC8AC43F 		.word	1069845164
 1229 01f0 14048F6F 		.word	1871643668
 1230 01f4 EF1AA43F 		.word	1067719407
 1231 01f8 4791B586 		.word	-2034921145
 1232 01fc 52FBE53F 		.word	1072036690
 1233 0200 08C89750 		.word	1352124424
 1234 0204 C1E1B13F 		.word	1068622273
 1235 0208 62D8614C 		.word	1281480802
 1236 020c FA7BD5BF 		.word	-1076528134
 1237 0210 B01EF7AD 		.word	-1376313680
 1238 0214 D689E63F 		.word	1072073174
 1239 0218 B34291EE 		.word	-292470093
 1240 021c E794E7BF 		.word	-1075342105
 1241 0220 E5D3635B 		.word	1533268965
 1242 0224 069CE6BF 		.word	-1075405818
 1243 0228 ECDCB419 		.word	431283436
 1244 022c A7A1E6BF 		.word	-1075404377
 1245 0230 289EB305 		.word	95657512
 1246 0234 84D6C5BF 		.word	-1077553532
 1247 0238 478FDFDB 		.word	-606105785
 1248 023c F467D43F 		.word	1070884852
 1249 0240 D1AFAD9F 		.word	-1616007215
 1250 0244 FEB3D83F 		.word	1071166462
 1251 0248 F81C588E 		.word	-1906828040
 1252 024c 9081E9BF 		.word	-1075215984
 1253 0250 AE105663 		.word	1666584750
 1254 0254 096BE1BF 		.word	-1075746039
 1255 0258 C493DDCC 		.word	-857893948
 1256 025c E847D53F 		.word	1070942184
 1257 0260 D061BEBC 		.word	-1128373808
 1258 0264 00FBC8BF 		.word	-1077347584
 1259 0268 11548D5E 		.word	1586320401
 1260 026c 0D50C0BF 		.word	-1077915635
 1261 0270 7100FDBE 		.word	-1090715535
 1262 0274 7FF3D93F 		.word	1071248255
 1263 0278 AFCDC64A 		.word	1254542767
 1264 027c CCB3D1BF 		.word	-1076775988
 1265 0280 DA3C0E83 		.word	-2096218918
 1266 0284 F9ABE7BF 		.word	-1075336199
 1267 0288 88BB7A15 		.word	360364936
 1268 028c 199DE63F 		.word	1072078105
 1269 0290 807D74EA 		.word	-361464448
 1270 0294 CA67DBBF 		.word	-1076140086
 1271 0298 4CC45BE7 		.word	-413416372
 1272 029c DF2EC7BF 		.word	-1077465377
 1273 02a0 BAD91F28 		.word	673175994
 1274 02a4 B7EDB7BF 		.word	-1078465097
 1275 02a8 95D39E92 		.word	-1835084907
 1276 02ac 7362E23F 		.word	1071800947
 1277 02b0 A51309A6 		.word	-1509354587
 1278 02b4 9AD9E0BF 		.word	-1075783270
 1279 02b8 D7DEA7AA 		.word	-1431839017
 1280 02bc D040E7BF 		.word	-1075363632
 1281 02c0 5D8B16A0 		.word	-1609135267
 1282 02c4 6DB5E4BF 		.word	-1075530387
 1283 02c8 48FC8A35 		.word	898301000
 1284 02cc 5CE4E7BF 		.word	-1075321764
 1285 02d0 CB82893F 		.word	1065976523
 1286 02d4 8A3AC3BF 		.word	-1077724534
 1287 02d8 F6984869 		.word	1766365430
 1288 02dc 368FC9BF 		.word	-1077309642
 1289 02e0 257497C4 		.word	-996707291
 1290 02e4 5911C73F 		.word	1070010713
 1291 02e8 79E92631 		.word	824633721
 1292 02ec 082CE53F 		.word	1071983624
 1293 02f0 C3F2E7DB 		.word	-605556029
 1294 02f4 82A5D4BF 		.word	-1076583038
 1295 02f8 56F5F23B 		.word	1005778262
 1296 02fc 4DE6E0BF 		.word	-1075780019
 1297 0300 D33252EF 		.word	-279825709
 1298 0304 A99CDBBF 		.word	-1076126551
 1299 0308 E0641BB8 		.word	-1206164256
 1300 030c 0375DBBF 		.word	-1076136701
 1301 0310 8657923C 		.word	1016223622
 1302 0314 D7F7DCBF 		.word	-1076037673
 1303 0318 0CAF2479 		.word	2032447244
 1304 031c AEEFD4BF 		.word	-1076564050
 1305 0320 C24CDBBF 		.word	-1076147006
 1306 0324 B2D2D4BF 		.word	-1076571470
 1307 0328 B37DC85B 		.word	1539866035
 1308 032c AE7EC43F 		.word	1069842094
 1309 0330 A647533D 		.word	1028868006
 1310 0334 99FFE73F 		.word	1072168857
 1311 0338 F8C61000 		.word	1099512
 1312 033c 1C7BE7BF 		.word	-1075348708
 1313 0340 D0B359F5 		.word	-178670640
 1314 0344 B9DAC63F 		.word	1069996729
 1315 0348 B000A60C 		.word	212205744
 1316 034c 1C50E1BF 		.word	-1075752932
 1317 0350 5AF0A2AF 		.word	-1348276134
 1318 0354 20CDD63F 		.word	1071041824
 1319 0358 276728EE 		.word	-299342041
 1320 035c 7893E83F 		.word	1072206712
 1321 0360 0F62670A 		.word	174547471
 1322 0364 9DD7BC3F 		.word	1069340573
 1323 0368 4ED02687 		.word	-2027499442
 1324 036c 4F3AA1BF 		.word	-1079952817
 1325 0370 9EEFA7C6 		.word	-962072674
 1326 0374 4B37D1BF 		.word	-1076807861
 1327 0378 E2218C9F 		.word	-1618206238
 1328 037c C6BDC73F 		.word	1070054854
 1329 0380 6B0BCF4B 		.word	1271860075
 1330 0384 C5C6C6BF 		.word	-1077492027
 1331 0388 8237A451 		.word	1369716610
 1332 038c 8193B93F 		.word	1069126529
 1333 0390 E0F3C308 		.word	147059680
 1334 0394 E1D1EFBF 		.word	-1074802207
 1335 0398 CAC51858 		.word	1478018506
 1336 039c C771E63F 		.word	1072067015
 1337 03a0 782975C9 		.word	-915068552
 1338 03a4 3846C4BF 		.word	-1077656008
 1339 03a8 FBAE08FE 		.word	-32985349
 1340 03ac B792E5BF 		.word	-1075473737
 1341              		.bss
 1342              		.align	2
 1343              		.set	.LANCHOR1,. + 0
 1346              	param:
 1347 0000 00000000 		.space	4
 1350              	layer_sizes:
 1351 0004 00000000 		.space	4
 1352              		.text
 1353              	.Letext0:
 1354              		.file 2 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\machine\\
 1355              		.file 3 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\sys\\_std
 1356              		.file 4 "parameters.h"
 1357              		.file 5 "hal.h"
 1358              		.file 6 "../hardware/victims/firmware/hal/stm32f3/stm32f3_hal.h"
 1359              		.file 7 "simpleserial.h"
 1360              		.file 8 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\string.h"
 1361              		.file 9 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\stdlib.h"
 1362              		.file 10 "<built-in>"
 1363              		.file 11 "mlp_classifier.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:75     .text.mlp:00000000 $t
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:83     .text.mlp:00000000 mlp
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:739    .text.mlp:000002b8 $d
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:760    .text.mlp:00000300 $t
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1032   .text.startup.main:00000000 $t
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1039   .text.startup.main:00000000 main
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1093   .text.startup.main:00000034 $d
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1350   .bss:00000004 layer_sizes
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1346   .bss:00000000 param
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1100   .rodata:00000000 $d
C:\Users\joris\AppData\Local\Temp\ccPHDciC.s:1342   .bss:00000000 $d

UNDEFINED SYMBOLS
__aeabi_i2d
malloc
strlen
strcpy
atoi
puts
exit
strtok
strcmp
memcpy
calloc
mlp_classifier
free
platform_init
init_uart
trigger_setup
simpleserial_init
simpleserial_addcmd
simpleserial_put
simpleserial_get
