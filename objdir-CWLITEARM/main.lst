   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_i2d
  16              		.section	.text.mlp,"ax",%progbits
  17              		.align	1
  18              		.global	mlp
  19              		.arch armv7e-m
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu softvfp
  25              	mlp:
  26              	.LVL0:
  27              	.LFB3:
  28              		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        **** Author: Manohar Mukku
   3:main.c        **** Date: 18.07.2018
   4:main.c        **** Desc: Multilayer Perceptron implementation in C
   5:main.c        **** GitHub: https://github.com/manoharmukku/multilayer-perceptron-in-c
   6:main.c        **** */
   7:main.c        **** 
   8:main.c        **** //#include "mlp_trainer.h"
   9:main.c        **** #include "mlp_classifier.h"
  10:main.c        **** //#include "read_csv.h"
  11:main.c        **** #include "simpleserial.h"
  12:main.c        **** #include "hal.h"
  13:main.c        **** 
  14:main.c        **** parameters* param;
  15:main.c        **** int* layer_sizes;
  16:main.c        **** 
  17:main.c        **** // uint8_t mlp_classifier_wrapper(uint8_t* arg1, uint8_t arg2) {
  18:main.c        **** //     // Call the mlp_classifier function with the global variables
  19:main.c        **** 
  20:main.c        **** //     mlp_classifier(param, layer_sizes);
  21:main.c        **** 
  22:main.c        **** //     // Return a dummy value (assuming simpleserial_addcmd doesn't need a meaningful return value
  23:main.c        **** //     return 0;
  24:main.c        **** // }
  25:main.c        **** 
  26:main.c        **** uint8_t mlp(uint8_t cmd, uint8_t scmd, uint8_t len, uint8_t *in) {
  29              		.loc 1 26 66 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 968
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  27:main.c        ****     /* Device reset detected */
  28:main.c        ****     //putch('r');
  29:main.c        ****     //printf("Device reset detected\n");
  30:main.c        ****     // putch('R');
  31:main.c        ****     // putch('E');
  32:main.c        ****     // putch('S');
  33:main.c        ****     // putch('E');
  34:main.c        ****     // putch('T');
  35:main.c        ****     // putch(' ');
  36:main.c        ****     // putch(' ');
  37:main.c        ****     // putch(' ');
  38:main.c        ****     // putch('\n');
  39:main.c        **** 
  40:main.c        **** 
  41:main.c        ****     //HARDCODED VALS
  42:main.c        ****     char *hardcoded_args[] = {
  33              		.loc 1 42 5 view .LVU1
  26:main.c        ****     /* Device reset detected */
  34              		.loc 1 26 66 is_stmt 0 view .LVU2
  35 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 36
  38              		.cfi_offset 4, -36
  39              		.cfi_offset 5, -32
  40              		.cfi_offset 6, -28
  41              		.cfi_offset 7, -24
  42              		.cfi_offset 8, -20
  43              		.cfi_offset 9, -16
  44              		.cfi_offset 10, -12
  45              		.cfi_offset 11, -8
  46              		.cfi_offset 14, -4
  47              		.loc 1 42 11 view .LVU3
  48 0004 AF4D     		ldr	r5, .L54
  49 0006 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
  50              	.LVL1:
  26:main.c        ****     /* Device reset detected */
  51              		.loc 1 26 66 view .LVU4
  52 0008 ADF5737D 		sub	sp, sp, #972
  53              	.LCFI1:
  54              		.cfi_def_cfa_offset 1008
  55              		.loc 1 42 11 view .LVU5
  56 000c 07AC     		add	r4, sp, #28
  57 000e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
  58 0010 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
  59 0012 0FC4     		stmia	r4!, {r0, r1, r2, r3}
  60 0014 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
  61 0016 0FC4     		stmia	r4!, {r0, r1, r2, r3}
  62 0018 95E80700 		ldm	r5, {r0, r1, r2}
  63 001c 84E80700 		stm	r4, {r0, r1, r2}
  43:main.c        ****         "executable_name", // new_argv[0] is typically the program name
  44:main.c        ****         "3",                // Number of hidden layers
  45:main.c        ****         "4,5,5",            // Size of each hidden layer
  46:main.c        ****         "softmax,relu,tanh",
  47:main.c        ****         "1",           
  48:main.c        ****         "sigmoid",         
  49:main.c        ****         "0.01",              
  50:main.c        ****         "10000 ",     
  51:main.c        ****         "data/data_train.csv", 
  52:main.c        ****         "1096",             
  53:main.c        ****         "5",               
  54:main.c        ****         "data/data_test.csv",
  55:main.c        ****         "275",              
  56:main.c        ****         "5",                
  57:main.c        ****         NULL                // Sentinel to mark the end of the array
  58:main.c        ****     };
  59:main.c        **** 
  60:main.c        ****     int new_argc = sizeof(hardcoded_args) / sizeof(char *) - 1; // Exclude the NULL sentinel
  64              		.loc 1 60 5 is_stmt 1 view .LVU6
  65              	.LVL2:
  61:main.c        **** 
  62:main.c        ****     // Allocate memory for the new new_argv
  63:main.c        ****     char **new_argv = (char **)malloc(new_argc * sizeof(char *));
  66              		.loc 1 63 5 view .LVU7
  67              		.loc 1 63 32 is_stmt 0 view .LVU8
  68 0020 3820     		movs	r0, #56
  69 0022 FFF7FEFF 		bl	malloc
  70              	.LVL3:
  71 0026 07AC     		add	r4, sp, #28
  72 0028 0546     		mov	r5, r0
  73              	.LVL4:
  64:main.c        **** 
  65:main.c        ****     // Copy the hardcoded strings to the new new_argv
  66:main.c        ****     for (int i = 0; i < new_argc; i++) {
  74              		.loc 1 66 5 is_stmt 1 view .LVU9
  75              	.LBB2:
  76              		.loc 1 66 10 view .LVU10
  77              		.loc 1 66 10 is_stmt 0 view .LVU11
  78 002a 061F     		subs	r6, r0, #4
  79 002c 00F13408 		add	r8, r0, #52
  80              	.LVL5:
  81              	.L2:
  67:main.c        ****         new_argv[i] = (char *)malloc((strlen(hardcoded_args[i]) + 1) * sizeof(char));
  82              		.loc 1 67 9 is_stmt 1 discriminator 3 view .LVU12
  83              		.loc 1 67 60 is_stmt 0 discriminator 3 view .LVU13
  84 0030 54F8047B 		ldr	r7, [r4], #4
  85              		.loc 1 67 39 discriminator 3 view .LVU14
  86 0034 3846     		mov	r0, r7
  87 0036 FFF7FEFF 		bl	strlen
  88              	.LVL6:
  89              		.loc 1 67 31 discriminator 3 view .LVU15
  90 003a 0130     		adds	r0, r0, #1
  91 003c FFF7FEFF 		bl	malloc
  92              	.LVL7:
  93              		.loc 1 67 21 discriminator 3 view .LVU16
  94 0040 46F8040F 		str	r0, [r6, #4]!
  68:main.c        ****         strcpy(new_argv[i], hardcoded_args[i]);
  95              		.loc 1 68 9 is_stmt 1 discriminator 3 view .LVU17
  96 0044 3946     		mov	r1, r7
  97 0046 FFF7FEFF 		bl	strcpy
  98              	.LVL8:
  66:main.c        ****         new_argv[i] = (char *)malloc((strlen(hardcoded_args[i]) + 1) * sizeof(char));
  99              		.loc 1 66 5 is_stmt 0 discriminator 3 view .LVU18
 100 004a 4645     		cmp	r6, r8
 101 004c F0D1     		bne	.L2
 102              	.LBE2:
  69:main.c        ****     }
  70:main.c        **** 
  71:main.c        ****     /*
  72:main.c        ****     new_argv[0]: Executable file name Ex: a.out
  73:main.c        ****     new_argv[1]: Number of hidden layers Ex: 3
  74:main.c        ****     new_argv[2]: Size of each hidden layer separated by comma Ex: 4,5,5
  75:main.c        ****     new_argv[3]: Hidden activation functions (identity - 1, sigmoid - 2, tanh - 3, relu - 4, softma
  76:main.c        ****     new_argv[4]: Alpha (L2 Regularization parameter value)
  77:main.c        ****     new_argv[5]: Maximum number of iterations
  78:main.c        ****     new_argv[6]: Number of units in output layer
  79:main.c        ****     new_argv[7]: Output activation function (identity - 1, sigmoid - 2, tanh - 3, relu - 4, softmax
  80:main.c        ****     new_argv[8]: Name of the csv file containing the train dataset
  81:main.c        ****     new_argv[9]: Number of rows or samples in the train dataset
  82:main.c        ****     new_argv[10]: Number of features including the output variable in the train dataset
  83:main.c        ****     new_argv[11]: Name of the csv file containing the test dataset
  84:main.c        ****     new_argv[12]: Number of rows or samples in the test dataset
  85:main.c        ****     new_argv[13]: Number of features including the output variable in the test dataset
  86:main.c        ****     */
  87:main.c        **** 
  88:main.c        ****     // Sanity check of command line arguments
  89:main.c        ****     // if (argc != 14) {
  90:main.c        ****     //     // Print help for execution syntax
  91:main.c        ****     //     printf("\nExecution syntax:\n");
  92:main.c        ****     //     printf("-----------------\n");
  93:main.c        ****     //     printf("Argument 0: Executable file name Ex: ./MLP \n");
  94:main.c        ****     //     printf("Argument 1: Number of hidden layers Ex: 3 \n");
  95:main.c        ****     //     printf("Argument 2: Number of units in each hidden layer from left to right separated by
  96:main.c        ****     //     printf("Argument 3: Activation function of each hidden layer from left to right separate
  97:main.c        ****     //     printf("Argument 4: Number of units in output layer (Specify 1 for binary classification
  98:main.c        ****     //     printf("Argument 5: Output activation function Ex: sigmoid \n");
  99:main.c        ****     //     printf("Argument 6: Learning rate parameter Ex: 0.01 \n");
 100:main.c        ****     //     printf("Argument 7: Maximum number of iterations to run during training Ex: 10000 \n");
 101:main.c        ****     //     printf("Argument 8: Path of the csv file containing the train dataset Ex: data/data_trai
 102:main.c        ****     //     printf("Argument 9: Number of rows in the train dataset (Number of samples) Ex: 1096 \n"
 103:main.c        ****     //     printf("Argument 10: Number of columns in the train dataset (Number of input features + 
 104:main.c        ****     //     printf("Argument 11: Path of the csv file containing the test dataset Ex: data/data_test
 105:main.c        ****     //     printf("Argument 12: Number of rows in the test dataset (Number of samples) Ex: 275 \n")
 106:main.c        ****     //     printf("Argument 13: Number of columns in the test dataset (Number of input features + 1
 107:main.c        ****     //     printf("Example:\n--------\n~$ ./MLP 3 4,5,5 softmax,relu,tanh 1 sigmoid 0.01 10000 data
 108:main.c        **** 
 109:main.c        ****     //     exit(0);
 110:main.c        ****     // }
 111:main.c        **** 
 112:main.c        **** 
 113:main.c        ****     // Create memory for training parameters struct
 114:main.c        ****     param = (parameters*)malloc(sizeof(parameters));
 103              		.loc 1 114 5 is_stmt 1 view .LVU19
 104              		.loc 1 114 26 is_stmt 0 view .LVU20
 105 004e 4020     		movs	r0, #64
 106 0050 FFF7FEFF 		bl	malloc
 107              	.LVL9:
 108              		.loc 1 114 11 view .LVU21
 109 0054 9C4C     		ldr	r4, .L54+4
 110              		.loc 1 114 26 view .LVU22
 111 0056 0646     		mov	r6, r0
 112              		.loc 1 114 11 view .LVU23
 113 0058 2060     		str	r0, [r4]
 115:main.c        **** 
 116:main.c        ****     // Number of hidden layers
 117:main.c        ****     param->n_hidden = atoi(new_argv[1]);
 114              		.loc 1 117 5 is_stmt 1 view .LVU24
 115              		.loc 1 117 23 is_stmt 0 view .LVU25
 116 005a 6868     		ldr	r0, [r5, #4]
 117 005c FFF7FEFF 		bl	atoi
 118              	.LVL10:
 119              		.loc 1 117 21 view .LVU26
 120 0060 3060     		str	r0, [r6]
 118:main.c        ****     // Sanity check of number of hidden layers
 119:main.c        ****     if (param->n_hidden < 0) {
 121              		.loc 1 119 5 is_stmt 1 view .LVU27
 122              		.loc 1 119 14 is_stmt 0 view .LVU28
 123 0062 2668     		ldr	r6, [r4]
 124 0064 3068     		ldr	r0, [r6]
 125              		.loc 1 119 8 view .LVU29
 126 0066 0028     		cmp	r0, #0
 127 0068 05DA     		bge	.L3
 120:main.c        ****         printf("Error: Number of hidden layers should be >= 0\n");
 128              		.loc 1 120 9 is_stmt 1 view .LVU30
 129 006a 9848     		ldr	r0, .L54+8
 130              	.LVL11:
 131              	.L53:
 121:main.c        ****         exit(0);
 122:main.c        ****     }
 123:main.c        **** 
 124:main.c        ****     // Size of each hidden layer
 125:main.c        ****     param->hidden_layers_size = (int*)malloc(param->n_hidden * sizeof(int));
 126:main.c        ****     int i;
 127:main.c        ****     char* tok;
 128:main.c        ****     for (i = 0, tok = strtok(new_argv[2], ","); i < param->n_hidden; i++) {
 129:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 130:main.c        ****         // Sanity check of size of hidden layer
 131:main.c        ****         if (param->hidden_layers_size[i] <= 0) {
 132:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 132              		.loc 1 132 13 is_stmt 0 view .LVU31
 133 006c FFF7FEFF 		bl	puts
 134              	.LVL12:
 133:main.c        ****             exit(0);
 135              		.loc 1 133 13 is_stmt 1 view .LVU32
 136 0070 0020     		movs	r0, #0
 137 0072 FFF7FEFF 		bl	exit
 138              	.LVL13:
 139              	.L3:
 125:main.c        ****     int i;
 140              		.loc 1 125 5 view .LVU33
 125:main.c        ****     int i;
 141              		.loc 1 125 39 is_stmt 0 view .LVU34
 142 0076 8000     		lsls	r0, r0, #2
 143 0078 FFF7FEFF 		bl	malloc
 144              	.LVL14:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 145              		.loc 1 128 23 view .LVU35
 146 007c 9449     		ldr	r1, .L54+12
 125:main.c        ****     int i;
 147              		.loc 1 125 31 view .LVU36
 148 007e 7060     		str	r0, [r6, #4]
 126:main.c        ****     char* tok;
 149              		.loc 1 126 5 is_stmt 1 view .LVU37
 127:main.c        ****     for (i = 0, tok = strtok(new_argv[2], ","); i < param->n_hidden; i++) {
 150              		.loc 1 127 5 view .LVU38
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 151              		.loc 1 128 5 view .LVU39
 152              	.LVL15:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 153              		.loc 1 128 23 is_stmt 0 view .LVU40
 154 0080 A868     		ldr	r0, [r5, #8]
 134:main.c        ****         }
 135:main.c        ****         tok = strtok(NULL, ",");
 155              		.loc 1 135 15 view .LVU41
 156 0082 DFF84C82 		ldr	r8, .L54+12
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 157              		.loc 1 128 23 view .LVU42
 158 0086 FFF7FEFF 		bl	strtok
 159              	.LVL16:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 160              		.loc 1 128 12 view .LVU43
 161 008a 0026     		movs	r6, #0
 162              	.LVL17:
 163              	.L4:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 164              		.loc 1 128 58 discriminator 1 view .LVU44
 165 008c 2768     		ldr	r7, [r4]
 166 008e 3B68     		ldr	r3, [r7]
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 167              		.loc 1 128 5 discriminator 1 view .LVU45
 168 0090 B342     		cmp	r3, r6
 169 0092 1DDC     		bgt	.L6
 136:main.c        ****     }
 137:main.c        **** 
 138:main.c        ****     // Hidden activation functions - Activation functions for each hidden layer
 139:main.c        ****     param->hidden_activation_functions = (int*)malloc(param->n_hidden * sizeof(int));
 170              		.loc 1 139 5 is_stmt 1 view .LVU46
 171              		.loc 1 139 48 is_stmt 0 view .LVU47
 172 0094 9800     		lsls	r0, r3, #2
 173 0096 FFF7FEFF 		bl	malloc
 174              	.LVL18:
 140:main.c        ****     for (i = 0, tok = strtok(new_argv[3], ","); i < param->n_hidden; i++) {
 175              		.loc 1 140 23 view .LVU48
 176 009a 8D49     		ldr	r1, .L54+12
 139:main.c        ****     for (i = 0, tok = strtok(new_argv[3], ","); i < param->n_hidden; i++) {
 177              		.loc 1 139 40 view .LVU49
 178 009c B860     		str	r0, [r7, #8]
 179              		.loc 1 140 5 is_stmt 1 view .LVU50
 180              	.LVL19:
 181              		.loc 1 140 23 is_stmt 0 view .LVU51
 182 009e E868     		ldr	r0, [r5, #12]
 141:main.c        ****         if (strcmp(tok, "identity") == 0) {
 183              		.loc 1 141 13 view .LVU52
 184 00a0 DFF84892 		ldr	r9, .L54+40
 142:main.c        ****             param->hidden_activation_functions[i] = 1;
 143:main.c        ****         }
 144:main.c        ****         else if (strcmp(tok, "sigmoid") == 0) {
 185              		.loc 1 144 18 view .LVU53
 186 00a4 DFF84CA2 		ldr	r10, .L54+48
 145:main.c        ****             param->hidden_activation_functions[i] = 2;
 146:main.c        ****         }
 147:main.c        ****         else if (strcmp(tok, "tanh") == 0) {
 187              		.loc 1 147 18 view .LVU54
 188 00a8 DFF84CB2 		ldr	fp, .L54+52
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 189              		.loc 1 140 23 view .LVU55
 190 00ac FFF7FEFF 		bl	strtok
 191              	.LVL20:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 192              		.loc 1 140 12 view .LVU56
 193 00b0 0026     		movs	r6, #0
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 194              		.loc 1 140 23 view .LVU57
 195 00b2 8046     		mov	r8, r0
 196              	.LVL21:
 197              	.L7:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 198              		.loc 1 140 58 discriminator 1 view .LVU58
 199 00b4 2768     		ldr	r7, [r4]
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 200              		.loc 1 140 5 discriminator 1 view .LVU59
 201 00b6 3B68     		ldr	r3, [r7]
 202 00b8 B342     		cmp	r3, r6
 203 00ba 1CDC     		bgt	.L14
 148:main.c        ****             param->hidden_activation_functions[i] = 3;
 149:main.c        ****         }
 150:main.c        ****         else if (strcmp(tok, "relu") == 0) {
 151:main.c        ****             param->hidden_activation_functions[i] = 4;
 152:main.c        ****         }
 153:main.c        ****         else if (strcmp(tok, "softmax") == 0) {
 154:main.c        ****             param->hidden_activation_functions[i] = 5;
 155:main.c        ****         }
 156:main.c        ****         else {
 157:main.c        ****             printf("Error: Invalid value for hidden activation function\n");
 158:main.c        ****             printf("Input either identity or sigmoid or tanh or relu or softmax for hidden activati
 159:main.c        ****             exit(0);
 160:main.c        ****         }
 161:main.c        **** 
 162:main.c        ****         tok = strtok(NULL, ",");
 163:main.c        ****     }
 164:main.c        **** 
 165:main.c        ****     // Output layer size
 166:main.c        ****     param->output_layer_size = atoi(new_argv[4]);
 204              		.loc 1 166 5 is_stmt 1 view .LVU60
 205              		.loc 1 166 32 is_stmt 0 view .LVU61
 206 00bc 2869     		ldr	r0, [r5, #16]
 207              	.LVL22:
 208              		.loc 1 166 32 view .LVU62
 209 00be FFF7FEFF 		bl	atoi
 210              	.LVL23:
 167:main.c        ****     if (param->output_layer_size <= 0) {
 211              		.loc 1 167 14 view .LVU63
 212 00c2 2668     		ldr	r6, [r4]
 213              	.LVL24:
 166:main.c        ****     if (param->output_layer_size <= 0) {
 214              		.loc 1 166 30 view .LVU64
 215 00c4 3862     		str	r0, [r7, #32]
 216              		.loc 1 167 5 is_stmt 1 view .LVU65
 217              		.loc 1 167 8 is_stmt 0 view .LVU66
 218 00c6 336A     		ldr	r3, [r6, #32]
 219 00c8 002B     		cmp	r3, #0
 220 00ca 49DC     		bgt	.L15
 168:main.c        ****         printf("Output layer size should be positive\n");
 221              		.loc 1 168 9 is_stmt 1 view .LVU67
 222 00cc 8148     		ldr	r0, .L54+16
 223 00ce CDE7     		b	.L53
 224              	.LVL25:
 225              	.L6:
 129:main.c        ****         // Sanity check of size of hidden layer
 226              		.loc 1 129 9 view .LVU68
 129:main.c        ****         // Sanity check of size of hidden layer
 227              		.loc 1 129 34 is_stmt 0 view .LVU69
 228 00d0 7F68     		ldr	r7, [r7, #4]
 129:main.c        ****         // Sanity check of size of hidden layer
 229              		.loc 1 129 40 view .LVU70
 230 00d2 FFF7FEFF 		bl	atoi
 231              	.LVL26:
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 232              		.loc 1 131 18 view .LVU71
 233 00d6 2368     		ldr	r3, [r4]
 129:main.c        ****         // Sanity check of size of hidden layer
 234              		.loc 1 129 38 view .LVU72
 235 00d8 47F82600 		str	r0, [r7, r6, lsl #2]
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 236              		.loc 1 131 9 is_stmt 1 view .LVU73
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 237              		.loc 1 131 38 is_stmt 0 view .LVU74
 238 00dc 5B68     		ldr	r3, [r3, #4]
 131:main.c        ****             printf("Error: Hidden layer sizes should be positive\n");
 239              		.loc 1 131 12 view .LVU75
 240 00de 53F82630 		ldr	r3, [r3, r6, lsl #2]
 241 00e2 002B     		cmp	r3, #0
 242 00e4 01DC     		bgt	.L5
 132:main.c        ****             exit(0);
 243              		.loc 1 132 13 is_stmt 1 view .LVU76
 244 00e6 7C48     		ldr	r0, .L54+20
 245 00e8 C0E7     		b	.L53
 246              	.L5:
 135:main.c        ****     }
 247              		.loc 1 135 9 discriminator 2 view .LVU77
 135:main.c        ****     }
 248              		.loc 1 135 15 is_stmt 0 discriminator 2 view .LVU78
 249 00ea 4146     		mov	r1, r8
 250 00ec 0020     		movs	r0, #0
 251 00ee FFF7FEFF 		bl	strtok
 252              	.LVL27:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 253              		.loc 1 128 71 discriminator 2 view .LVU79
 254 00f2 0136     		adds	r6, r6, #1
 255              	.LVL28:
 128:main.c        ****         param->hidden_layers_size[i] = atoi(tok);
 256              		.loc 1 128 71 discriminator 2 view .LVU80
 257 00f4 CAE7     		b	.L4
 258              	.LVL29:
 259              	.L14:
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 260              		.loc 1 141 9 is_stmt 1 view .LVU81
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 261              		.loc 1 141 13 is_stmt 0 view .LVU82
 262 00f6 4946     		mov	r1, r9
 263 00f8 4046     		mov	r0, r8
 264              	.LVL30:
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 265              		.loc 1 141 13 view .LVU83
 266 00fa FFF7FEFF 		bl	strcmp
 267              	.LVL31:
 141:main.c        ****             param->hidden_activation_functions[i] = 1;
 268              		.loc 1 141 12 view .LVU84
 269 00fe 50B9     		cbnz	r0, .L8
 142:main.c        ****         }
 270              		.loc 1 142 13 is_stmt 1 view .LVU85
 142:main.c        ****         }
 271              		.loc 1 142 51 is_stmt 0 view .LVU86
 272 0100 BB68     		ldr	r3, [r7, #8]
 273 0102 0122     		movs	r2, #1
 274              	.L50:
 154:main.c        ****         }
 275              		.loc 1 154 51 view .LVU87
 276 0104 43F82620 		str	r2, [r3, r6, lsl #2]
 162:main.c        ****     }
 277              		.loc 1 162 9 is_stmt 1 view .LVU88
 162:main.c        ****     }
 278              		.loc 1 162 15 is_stmt 0 view .LVU89
 279 0108 7149     		ldr	r1, .L54+12
 280 010a 0020     		movs	r0, #0
 281 010c FFF7FEFF 		bl	strtok
 282              	.LVL32:
 140:main.c        ****         if (strcmp(tok, "identity") == 0) {
 283              		.loc 1 140 71 view .LVU90
 284 0110 0136     		adds	r6, r6, #1
 285              	.LVL33:
 162:main.c        ****     }
 286              		.loc 1 162 15 view .LVU91
 287 0112 8046     		mov	r8, r0
 288              	.LVL34:
 162:main.c        ****     }
 289              		.loc 1 162 15 view .LVU92
 290 0114 CEE7     		b	.L7
 291              	.LVL35:
 292              	.L8:
 144:main.c        ****             param->hidden_activation_functions[i] = 2;
 293              		.loc 1 144 14 is_stmt 1 view .LVU93
 144:main.c        ****             param->hidden_activation_functions[i] = 2;
 294              		.loc 1 144 18 is_stmt 0 view .LVU94
 295 0116 5146     		mov	r1, r10
 296 0118 4046     		mov	r0, r8
 297 011a FFF7FEFF 		bl	strcmp
 298              	.LVL36:
 144:main.c        ****             param->hidden_activation_functions[i] = 2;
 299              		.loc 1 144 17 view .LVU95
 300 011e 10B9     		cbnz	r0, .L10
 145:main.c        ****         }
 301              		.loc 1 145 13 is_stmt 1 view .LVU96
 145:main.c        ****         }
 302              		.loc 1 145 51 is_stmt 0 view .LVU97
 303 0120 BB68     		ldr	r3, [r7, #8]
 304 0122 0222     		movs	r2, #2
 305 0124 EEE7     		b	.L50
 306              	.L10:
 147:main.c        ****             param->hidden_activation_functions[i] = 3;
 307              		.loc 1 147 14 is_stmt 1 view .LVU98
 147:main.c        ****             param->hidden_activation_functions[i] = 3;
 308              		.loc 1 147 18 is_stmt 0 view .LVU99
 309 0126 5946     		mov	r1, fp
 310 0128 4046     		mov	r0, r8
 311 012a FFF7FEFF 		bl	strcmp
 312              	.LVL37:
 147:main.c        ****             param->hidden_activation_functions[i] = 3;
 313              		.loc 1 147 17 view .LVU100
 314 012e 10B9     		cbnz	r0, .L11
 148:main.c        ****         }
 315              		.loc 1 148 13 is_stmt 1 view .LVU101
 148:main.c        ****         }
 316              		.loc 1 148 51 is_stmt 0 view .LVU102
 317 0130 BB68     		ldr	r3, [r7, #8]
 318 0132 0322     		movs	r2, #3
 319 0134 E6E7     		b	.L50
 320              	.L11:
 150:main.c        ****             param->hidden_activation_functions[i] = 4;
 321              		.loc 1 150 14 is_stmt 1 view .LVU103
 150:main.c        ****             param->hidden_activation_functions[i] = 4;
 322              		.loc 1 150 18 is_stmt 0 view .LVU104
 323 0136 6949     		ldr	r1, .L54+24
 324 0138 4046     		mov	r0, r8
 325 013a FFF7FEFF 		bl	strcmp
 326              	.LVL38:
 150:main.c        ****             param->hidden_activation_functions[i] = 4;
 327              		.loc 1 150 17 view .LVU105
 328 013e 10B9     		cbnz	r0, .L12
 151:main.c        ****         }
 329              		.loc 1 151 13 is_stmt 1 view .LVU106
 151:main.c        ****         }
 330              		.loc 1 151 51 is_stmt 0 view .LVU107
 331 0140 BB68     		ldr	r3, [r7, #8]
 332 0142 0422     		movs	r2, #4
 333 0144 DEE7     		b	.L50
 334              	.L12:
 153:main.c        ****             param->hidden_activation_functions[i] = 5;
 335              		.loc 1 153 14 is_stmt 1 view .LVU108
 153:main.c        ****             param->hidden_activation_functions[i] = 5;
 336              		.loc 1 153 18 is_stmt 0 view .LVU109
 337 0146 6649     		ldr	r1, .L54+28
 338 0148 4046     		mov	r0, r8
 339 014a FFF7FEFF 		bl	strcmp
 340              	.LVL39:
 153:main.c        ****             param->hidden_activation_functions[i] = 5;
 341              		.loc 1 153 17 view .LVU110
 342 014e 10B9     		cbnz	r0, .L13
 154:main.c        ****         }
 343              		.loc 1 154 13 is_stmt 1 view .LVU111
 154:main.c        ****         }
 344              		.loc 1 154 51 is_stmt 0 view .LVU112
 345 0150 BB68     		ldr	r3, [r7, #8]
 346 0152 0522     		movs	r2, #5
 347 0154 D6E7     		b	.L50
 348              	.L13:
 157:main.c        ****             printf("Input either identity or sigmoid or tanh or relu or softmax for hidden activati
 349              		.loc 1 157 13 is_stmt 1 view .LVU113
 350 0156 6348     		ldr	r0, .L54+32
 351 0158 FFF7FEFF 		bl	puts
 352              	.LVL40:
 158:main.c        ****             exit(0);
 353              		.loc 1 158 13 view .LVU114
 354 015c 6248     		ldr	r0, .L54+36
 355 015e 85E7     		b	.L53
 356              	.LVL41:
 357              	.L15:
 169:main.c        ****         exit(0);
 170:main.c        ****     }
 171:main.c        **** 
 172:main.c        ****     // Output activation function
 173:main.c        ****     if (strcmp(new_argv[5], "identity") == 0) {
 358              		.loc 1 173 5 view .LVU115
 359              		.loc 1 173 9 is_stmt 0 view .LVU116
 360 0160 6F69     		ldr	r7, [r5, #20]
 361 0162 6249     		ldr	r1, .L54+40
 362 0164 3846     		mov	r0, r7
 363 0166 FFF7FEFF 		bl	strcmp
 364              	.LVL42:
 365              		.loc 1 173 8 view .LVU117
 366 016a 98B9     		cbnz	r0, .L16
 174:main.c        ****         param->output_activation_function = 1;
 367              		.loc 1 174 9 is_stmt 1 view .LVU118
 368              		.loc 1 174 43 is_stmt 0 view .LVU119
 369 016c 0123     		movs	r3, #1
 370              	.L51:
 175:main.c        ****     }
 176:main.c        ****     else if (strcmp(new_argv[5], "sigmoid") == 0) {
 177:main.c        ****         param->output_activation_function = 2;
 178:main.c        ****     }
 179:main.c        ****     else if (strcmp(new_argv[5], "tanh") == 0) {
 180:main.c        ****         param->output_activation_function = 3;
 181:main.c        ****     }
 182:main.c        ****     else if (strcmp(new_argv[5], "relu") == 0) {
 183:main.c        ****         param->output_activation_function = 4;
 184:main.c        ****     }
 185:main.c        ****     else if (strcmp(new_argv[5], "softmax") == 0) {
 186:main.c        ****         param->output_activation_function = 5;
 371              		.loc 1 186 43 view .LVU120
 372 016e 7362     		str	r3, [r6, #36]
 187:main.c        ****     }
 188:main.c        ****     else {
 189:main.c        ****         printf("Error: Invalid value for output activation function\n");
 190:main.c        ****         printf("Input either identity or sigmoid or tanh or relu or softmax for output activation f
 191:main.c        ****         exit(0);
 192:main.c        ****     }
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        ****     // L2 Regularization parameter
 196:main.c        ****     param->learning_rate = atoi(new_argv[6]);
 373              		.loc 1 196 5 is_stmt 1 view .LVU121
 374              		.loc 1 196 28 is_stmt 0 view .LVU122
 375 0170 A869     		ldr	r0, [r5, #24]
 376 0172 FFF7FEFF 		bl	atoi
 377              	.LVL43:
 378              		.loc 1 196 26 view .LVU123
 379 0176 FFF7FEFF 		bl	__aeabi_i2d
 380              	.LVL44:
 381              		.loc 1 196 10 view .LVU124
 382 017a 2668     		ldr	r6, [r4]
 383              		.loc 1 196 26 view .LVU125
 384 017c C6E90401 		strd	r0, [r6, #16]
 197:main.c        **** 
 198:main.c        ****     // Max. number of iterations
 199:main.c        ****     param->n_iterations_max = atoi(new_argv[7]);
 385              		.loc 1 199 5 is_stmt 1 view .LVU126
 386              		.loc 1 199 31 is_stmt 0 view .LVU127
 387 0180 E869     		ldr	r0, [r5, #28]
 388 0182 FFF7FEFF 		bl	atoi
 389              	.LVL45:
 200:main.c        ****     if (param->n_iterations_max <= 0) {
 390              		.loc 1 200 14 view .LVU128
 391 0186 2568     		ldr	r5, [r4]
 392              	.LVL46:
 199:main.c        ****     if (param->n_iterations_max <= 0) {
 393              		.loc 1 199 29 view .LVU129
 394 0188 B061     		str	r0, [r6, #24]
 395              		.loc 1 200 5 is_stmt 1 view .LVU130
 396              		.loc 1 200 8 is_stmt 0 view .LVU131
 397 018a AB69     		ldr	r3, [r5, #24]
 398 018c 002B     		cmp	r3, #0
 399 018e 22DC     		bgt	.L22
 201:main.c        ****         printf("Max. number of iterations value should be positive\n");
 400              		.loc 1 201 9 is_stmt 1 view .LVU132
 401 0190 5748     		ldr	r0, .L54+44
 402 0192 6BE7     		b	.L53
 403              	.LVL47:
 404              	.L16:
 176:main.c        ****         param->output_activation_function = 2;
 405              		.loc 1 176 10 view .LVU133
 176:main.c        ****         param->output_activation_function = 2;
 406              		.loc 1 176 14 is_stmt 0 view .LVU134
 407 0194 5749     		ldr	r1, .L54+48
 408 0196 3846     		mov	r0, r7
 409 0198 FFF7FEFF 		bl	strcmp
 410              	.LVL48:
 176:main.c        ****         param->output_activation_function = 2;
 411              		.loc 1 176 13 view .LVU135
 412 019c 08B9     		cbnz	r0, .L18
 177:main.c        ****     }
 413              		.loc 1 177 9 is_stmt 1 view .LVU136
 177:main.c        ****     }
 414              		.loc 1 177 43 is_stmt 0 view .LVU137
 415 019e 0223     		movs	r3, #2
 416 01a0 E5E7     		b	.L51
 417              	.L18:
 179:main.c        ****         param->output_activation_function = 3;
 418              		.loc 1 179 10 is_stmt 1 view .LVU138
 179:main.c        ****         param->output_activation_function = 3;
 419              		.loc 1 179 14 is_stmt 0 view .LVU139
 420 01a2 5549     		ldr	r1, .L54+52
 421 01a4 3846     		mov	r0, r7
 422 01a6 FFF7FEFF 		bl	strcmp
 423              	.LVL49:
 179:main.c        ****         param->output_activation_function = 3;
 424              		.loc 1 179 13 view .LVU140
 425 01aa 08B9     		cbnz	r0, .L19
 180:main.c        ****     }
 426              		.loc 1 180 9 is_stmt 1 view .LVU141
 180:main.c        ****     }
 427              		.loc 1 180 43 is_stmt 0 view .LVU142
 428 01ac 0323     		movs	r3, #3
 429 01ae DEE7     		b	.L51
 430              	.L19:
 182:main.c        ****         param->output_activation_function = 4;
 431              		.loc 1 182 10 is_stmt 1 view .LVU143
 182:main.c        ****         param->output_activation_function = 4;
 432              		.loc 1 182 14 is_stmt 0 view .LVU144
 433 01b0 4A49     		ldr	r1, .L54+24
 434 01b2 3846     		mov	r0, r7
 435 01b4 FFF7FEFF 		bl	strcmp
 436              	.LVL50:
 182:main.c        ****         param->output_activation_function = 4;
 437              		.loc 1 182 13 view .LVU145
 438 01b8 08B9     		cbnz	r0, .L20
 183:main.c        ****     }
 439              		.loc 1 183 9 is_stmt 1 view .LVU146
 183:main.c        ****     }
 440              		.loc 1 183 43 is_stmt 0 view .LVU147
 441 01ba 0423     		movs	r3, #4
 442 01bc D7E7     		b	.L51
 443              	.L20:
 185:main.c        ****         param->output_activation_function = 5;
 444              		.loc 1 185 10 is_stmt 1 view .LVU148
 185:main.c        ****         param->output_activation_function = 5;
 445              		.loc 1 185 14 is_stmt 0 view .LVU149
 446 01be 4849     		ldr	r1, .L54+28
 447 01c0 3846     		mov	r0, r7
 448 01c2 FFF7FEFF 		bl	strcmp
 449              	.LVL51:
 185:main.c        ****         param->output_activation_function = 5;
 450              		.loc 1 185 13 view .LVU150
 451 01c6 08B9     		cbnz	r0, .L21
 186:main.c        ****     }
 452              		.loc 1 186 9 is_stmt 1 view .LVU151
 186:main.c        ****     }
 453              		.loc 1 186 43 is_stmt 0 view .LVU152
 454 01c8 0523     		movs	r3, #5
 455 01ca D0E7     		b	.L51
 456              	.L21:
 189:main.c        ****         printf("Input either identity or sigmoid or tanh or relu or softmax for output activation f
 457              		.loc 1 189 9 is_stmt 1 view .LVU153
 458 01cc 4B48     		ldr	r0, .L54+56
 459 01ce FFF7FEFF 		bl	puts
 460              	.LVL52:
 190:main.c        ****         exit(0);
 461              		.loc 1 190 9 view .LVU154
 462 01d2 4B48     		ldr	r0, .L54+60
 463 01d4 4AE7     		b	.L53
 464              	.LVL53:
 465              	.L22:
 202:main.c        ****         exit(0);
 203:main.c        ****     }
 204:main.c        **** 
 205:main.c        ****     // Momentum
 206:main.c        ****     //param->momentum = atoi(new_argv[6]);
 207:main.c        **** 
 208:main.c        ****     // Get the parameters of the train dataset
 209:main.c        ****     //char* train_filename = new_argv[8];
 210:main.c        ****     //param->train_sample_size = atoi(new_argv[9]);
 211:main.c        ****     // Feature size = Number of input features + 1 output feature
 212:main.c        ****     //param->feature_size = atoi(new_argv[10]);
 213:main.c        **** 
 214:main.c        ****     // Create 2D array memory for the dataset
 215:main.c        ****     //param->data_train = (double**)malloc(param->train_sample_size * sizeof(double*));
 216:main.c        ****     //for (i = 0; i < param->train_sample_size; i++)
 217:main.c        ****     //    param->data_train[i] = (double*)malloc(param->feature_size * sizeof(double));
 218:main.c        **** 
 219:main.c        ****     // Read the train dataset from the csv into the 2D array
 220:main.c        ****     //read_csv(train_filename, param->train_sample_size, param->feature_size, param->data_train);
 221:main.c        ****     
 222:main.c        ****     double test_lines[][5] = {
 466              		.loc 1 222 5 view .LVU155
 467              		.loc 1 222 12 is_stmt 0 view .LVU156
 468 01d6 C822     		movs	r2, #200
 469 01d8 4A49     		ldr	r1, .L54+64
 470 01da 16A8     		add	r0, sp, #88
 471 01dc FFF7FEFF 		bl	memcpy
 472              	.LVL54:
 223:main.c        ****         {1.602, 6.1251, 0.5292399999999999, 0.4788600000000001, 0},
 224:main.c        ****         {-2.2918, -7.2570000000000014, 7.9597, 0.9211, 1},
 225:main.c        ****         {-0.6907800000000001, -0.5007699999999999, -0.35417, 0.47498, 1},
 226:main.c        ****         {1.6408, 4.2503, -4.9023, -2.6621, 1},
 227:main.c        ****         {3.577, 2.4004, 1.8908, 0.73231, 0},
 228:main.c        ****     };
 229:main.c        **** 
 230:main.c        ****     int test_sample_size = sizeof(test_lines) / sizeof(test_lines[0]);
 473              		.loc 1 230 5 is_stmt 1 view .LVU157
 231:main.c        ****     int feature_size = sizeof(test_lines[0]) / sizeof(double);
 474              		.loc 1 231 5 view .LVU158
 232:main.c        **** 
 233:main.c        ****     // Get the parameters of the test dataset
 234:main.c        ****     //char* test_filename = new_argv[11];
 235:main.c        ****     //param->test_sample_size = atoi(new_argv[12]);
 236:main.c        ****     // Feature size = Number of input features + 1 output feature
 237:main.c        ****     //param->feature_size = atoi(new_argv[13]);
 238:main.c        **** 
 239:main.c        ****    // Create 2D array memory for the test data
 240:main.c        ****     param->data_test = (double **)malloc(test_sample_size * sizeof(double *));
 475              		.loc 1 240 5 view .LVU159
 476              		.loc 1 240 35 is_stmt 0 view .LVU160
 477 01e0 1420     		movs	r0, #20
 478 01e2 FFF7FEFF 		bl	malloc
 479              	.LVL55:
 480 01e6 0DF15808 		add	r8, sp, #88
 481              	.LVL56:
 482              		.loc 1 240 22 view .LVU161
 483 01ea E862     		str	r0, [r5, #44]
 241:main.c        ****     for (int i = 0; i < test_sample_size; i++) {
 484              		.loc 1 241 5 is_stmt 1 view .LVU162
 485              	.LBB3:
 486              		.loc 1 241 10 view .LVU163
 487              	.LVL57:
 488              		.loc 1 241 10 is_stmt 0 view .LVU164
 489              	.LBE3:
 240:main.c        ****     for (int i = 0; i < test_sample_size; i++) {
 490              		.loc 1 240 22 view .LVU165
 491 01ec 4FF00009 		mov	r9, #0
 492              	.LVL58:
 493              	.L23:
 494              	.LBB4:
 242:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 495              		.loc 1 242 9 is_stmt 1 discriminator 3 view .LVU166
 496              		.loc 1 242 41 is_stmt 0 discriminator 3 view .LVU167
 497 01f0 2820     		movs	r0, #40
 498              		.loc 1 242 25 discriminator 3 view .LVU168
 499 01f2 EE6A     		ldr	r6, [r5, #44]
 500              		.loc 1 242 41 discriminator 3 view .LVU169
 501 01f4 FFF7FEFF 		bl	malloc
 502              	.LVL59:
 243:main.c        ****         memcpy(param->data_test[i], test_lines[i], feature_size * sizeof(double));
 503              		.loc 1 243 9 discriminator 3 view .LVU170
 504 01f8 4746     		mov	r7, r8
 242:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 505              		.loc 1 242 29 discriminator 3 view .LVU171
 506 01fa 46F80900 		str	r0, [r6, r9]
 507              		.loc 1 243 9 is_stmt 1 discriminator 3 view .LVU172
 508 01fe 0646     		mov	r6, r0
 509 0200 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 510 0202 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 511 0204 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 512 0206 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 513 0208 97E80300 		ldm	r7, {r0, r1}
 514 020c 09F10409 		add	r9, r9, #4
 241:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 515              		.loc 1 241 5 is_stmt 0 discriminator 3 view .LVU173
 516 0210 B9F1140F 		cmp	r9, #20
 517              		.loc 1 243 9 discriminator 3 view .LVU174
 518 0214 86E80300 		stm	r6, {r0, r1}
 519              		.loc 1 243 9 discriminator 3 view .LVU175
 520 0218 08F12808 		add	r8, r8, #40
 241:main.c        ****         param->data_test[i] = (double *)malloc(feature_size * sizeof(double));
 521              		.loc 1 241 5 discriminator 3 view .LVU176
 522 021c E8D1     		bne	.L23
 523              	.LBE4:
 244:main.c        ****     }
 245:main.c        **** 
 246:main.c        ****     param->test_sample_size = test_sample_size;
 524              		.loc 1 246 5 is_stmt 1 view .LVU177
 247:main.c        ****     param->feature_size = feature_size;
 248:main.c        **** 
 249:main.c        ****     // Read the test dataset from the csv into the 2D array
 250:main.c        ****     //read_csv(test_filename, param->test_sample_size, param->feature_size, param->data_test);
 251:main.c        **** 
 252:main.c        ****     // Total number of layers
 253:main.c        ****     int n_layers = param->n_hidden + 2;
 525              		.loc 1 253 25 is_stmt 0 view .LVU178
 526 021e 2E68     		ldr	r6, [r5]
 246:main.c        ****     param->feature_size = feature_size;
 527              		.loc 1 246 29 view .LVU179
 528 0220 0523     		movs	r3, #5
 529 0222 AB63     		str	r3, [r5, #56]
 247:main.c        ****     param->feature_size = feature_size;
 530              		.loc 1 247 5 is_stmt 1 view .LVU180
 247:main.c        ****     param->feature_size = feature_size;
 531              		.loc 1 247 25 is_stmt 0 view .LVU181
 532 0224 2B63     		str	r3, [r5, #48]
 533              		.loc 1 253 5 is_stmt 1 view .LVU182
 534              	.LVL60:
 254:main.c        **** 
 255:main.c        ****     // Save the sizes of layers in an array
 256:main.c        ****     layer_sizes = (int*)calloc(n_layers, sizeof(int));
 535              		.loc 1 256 5 view .LVU183
 536              		.loc 1 256 25 is_stmt 0 view .LVU184
 537 0226 0421     		movs	r1, #4
 538 0228 B01C     		adds	r0, r6, #2
 539              	.LVL61:
 540              		.loc 1 256 25 view .LVU185
 541 022a FFF7FEFF 		bl	calloc
 542              	.LVL62:
 257:main.c        **** 
 258:main.c        ****     layer_sizes[0] = param->feature_size - 1;
 543              		.loc 1 258 20 view .LVU186
 544 022e 0423     		movs	r3, #4
 545 0230 0360     		str	r3, [r0]
 259:main.c        ****     layer_sizes[n_layers-1] = param->output_layer_size;
 546              		.loc 1 259 16 view .LVU187
 547 0232 06F18043 		add	r3, r6, #1073741824
 256:main.c        **** 
 548              		.loc 1 256 17 view .LVU188
 549 0236 344A     		ldr	r2, .L54+68
 550              		.loc 1 259 36 view .LVU189
 551 0238 296A     		ldr	r1, [r5, #32]
 256:main.c        **** 
 552              		.loc 1 256 17 view .LVU190
 553 023a 1060     		str	r0, [r2]
 258:main.c        ****     layer_sizes[n_layers-1] = param->output_layer_size;
 554              		.loc 1 258 5 is_stmt 1 view .LVU191
 555              		.loc 1 259 5 view .LVU192
 556              		.loc 1 259 16 is_stmt 0 view .LVU193
 557 023c 0133     		adds	r3, r3, #1
 256:main.c        **** 
 558              		.loc 1 256 25 view .LVU194
 559 023e 0746     		mov	r7, r0
 560              		.loc 1 259 29 view .LVU195
 561 0240 40F82310 		str	r1, [r0, r3, lsl #2]
 260:main.c        **** 
 261:main.c        ****     for (i = 1; i < n_layers-1 ; i++)
 562              		.loc 1 261 5 is_stmt 1 view .LVU196
 563              	.LVL63:
 564              		.loc 1 261 5 is_stmt 0 view .LVU197
 565 0244 0292     		str	r2, [sp, #8]
 566              		.loc 1 261 12 view .LVU198
 567 0246 0123     		movs	r3, #1
 568              	.LVL64:
 569              	.L24:
 570              		.loc 1 261 5 discriminator 1 view .LVU199
 571 0248 9E42     		cmp	r6, r3
 572 024a 27DA     		bge	.L25
 262:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 263:main.c        **** 
 264:main.c        ****     // Create memory for the weight matrices between layers
 265:main.c        ****     // weight is a pointer to the array of 2D arrays between the layers
 266:main.c        ****     param->weight = (double***)calloc(n_layers - 1, sizeof(double**));
 573              		.loc 1 266 5 is_stmt 1 view .LVU200
 574              		.loc 1 266 32 is_stmt 0 view .LVU201
 575 024c 0421     		movs	r1, #4
 576 024e 701C     		adds	r0, r6, #1
 577 0250 FFF7FEFF 		bl	calloc
 578              	.LVL65:
 267:main.c        **** 
 268:main.c        ****     // Each 2D array between two layers i and i+1 is of size ((layer_size[i]+1) x layer_size[i+1])
 269:main.c        ****     // The weight matrix includes weights for the bias terms too
 270:main.c        ****     for (i = 0; i < n_layers-1; i++)
 579              		.loc 1 270 12 view .LVU202
 580 0254 4FF00009 		mov	r9, #0
 266:main.c        **** 
 581              		.loc 1 266 32 view .LVU203
 582 0258 8046     		mov	r8, r0
 266:main.c        **** 
 583              		.loc 1 266 19 view .LVU204
 584 025a E863     		str	r0, [r5, #60]
 585              		.loc 1 270 5 is_stmt 1 view .LVU205
 586              	.LVL66:
 587              	.L26:
 588              		.loc 1 270 5 is_stmt 0 discriminator 1 view .LVU206
 589 025c 4E45     		cmp	r6, r9
 590 025e 26DA     		bge	.L27
 591 0260 0197     		str	r7, [sp, #4]
 592              		.loc 1 270 5 view .LVU207
 593 0262 4346     		mov	r3, r8
 594 0264 B946     		mov	r9, r7
 595              	.LVL67:
 271:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 272:main.c        **** 
 273:main.c        ****     int j;
 274:main.c        ****     for (i = 0; i < n_layers-1; i++)
 596              		.loc 1 274 12 view .LVU208
 597 0266 4FF0000B 		mov	fp, #0
 598              	.L28:
 599              	.LVL68:
 600              		.loc 1 274 5 discriminator 1 view .LVU209
 601 026a 5E45     		cmp	r6, fp
 602 026c 68DA     		bge	.L46
 275:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 276:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 277:main.c        **** 
 278:main.c        ****     double weights[] = {
 603              		.loc 1 278 5 is_stmt 1 view .LVU210
 604              		.loc 1 278 12 is_stmt 0 view .LVU211
 605 026e 0DF5907B 		add	fp, sp, #288
 606              	.LVL69:
 607              		.loc 1 278 12 view .LVU212
 608 0272 4FF42A72 		mov	r2, #680
 609 0276 2549     		ldr	r1, .L54+72
 610 0278 5846     		mov	r0, fp
 611 027a FFF7FEFF 		bl	memcpy
 612              	.LVL70:
 279:main.c        ****     0.725865, 0.441536, -0.799100, 0.009719, 0.445643, -0.595062, -0.250179, 0.208894, 0.276722, 0.
 280:main.c        ****     0.011293, 0.240472, 0.452365, 0.149054, -0.471252, 0.584530, -0.208878, -0.344829, 0.160482, 0.
 281:main.c        ****     -0.797066, -0.544316, 0.332514, -0.195160, -0.127443, 0.405487, -0.276599, -0.739743, 0.706677,
 282:main.c        ****     0.661625, -0.322602, -0.528113, -0.431437, -0.429017, -0.452627, -0.327129, -0.325360, 0.160116
 283:main.c        ****     0.099907, -0.994370, 0.701389, -0.158393, -0.674160
 284:main.c        ****     };
 285:main.c        **** 
 286:main.c        ****     int weightIndex = 0;
 613              		.loc 1 286 5 is_stmt 1 view .LVU213
 287:main.c        ****     for (int i = 0; i < n_layers - 1; i++) {
 614              		.loc 1 287 5 view .LVU214
 615              	.LBB5:
 616              		.loc 1 287 10 view .LVU215
 617              		.loc 1 287 14 is_stmt 0 view .LVU216
 618 027e 0022     		movs	r2, #0
 619              	.LBE5:
 286:main.c        ****     for (int i = 0; i < n_layers - 1; i++) {
 620              		.loc 1 286 9 view .LVU217
 621 0280 9446     		mov	ip, r2
 622 0282 CDF814B0 		str	fp, [sp, #20]
 623              	.LVL71:
 624              	.L31:
 625              	.LBB10:
 626              		.loc 1 287 5 discriminator 1 view .LVU218
 627 0286 9642     		cmp	r6, r2
 628 0288 C0F28380 		blt	.L35
 629              	.LBB6:
 288:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 630              		.loc 1 288 27 view .LVU219
 631 028c 019B     		ldr	r3, [sp, #4]
 632 028e 1946     		mov	r1, r3
 633 0290 51F8043B 		ldr	r3, [r1], #4
 634 0294 0393     		str	r3, [sp, #12]
 635 0296 0191     		str	r1, [sp, #4]
 636              		.loc 1 288 18 view .LVU220
 637 0298 0023     		movs	r3, #0
 638 029a 67E0     		b	.L52
 639              	.LVL72:
 640              	.L25:
 641              		.loc 1 288 18 view .LVU221
 642              	.LBE6:
 643              	.LBE10:
 262:main.c        **** 
 644              		.loc 1 262 9 is_stmt 1 discriminator 3 view .LVU222
 262:main.c        **** 
 645              		.loc 1 262 51 is_stmt 0 discriminator 3 view .LVU223
 646 029c 6A68     		ldr	r2, [r5, #4]
 647 029e 02EB8302 		add	r2, r2, r3, lsl #2
 648 02a2 52F8042C 		ldr	r2, [r2, #-4]
 262:main.c        **** 
 649              		.loc 1 262 24 discriminator 3 view .LVU224
 650 02a6 47F82320 		str	r2, [r7, r3, lsl #2]
 261:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 651              		.loc 1 261 35 discriminator 3 view .LVU225
 652 02aa 0133     		adds	r3, r3, #1
 653              	.LVL73:
 261:main.c        ****         layer_sizes[i] = param->hidden_layers_size[i-1];
 654              		.loc 1 261 35 discriminator 3 view .LVU226
 655 02ac CCE7     		b	.L24
 656              	.LVL74:
 657              	.L27:
 271:main.c        **** 
 658              		.loc 1 271 9 is_stmt 1 discriminator 3 view .LVU227
 271:main.c        **** 
 659              		.loc 1 271 59 is_stmt 0 discriminator 3 view .LVU228
 660 02ae 57F82900 		ldr	r0, [r7, r9, lsl #2]
 271:main.c        **** 
 661              		.loc 1 271 38 discriminator 3 view .LVU229
 662 02b2 0421     		movs	r1, #4
 663 02b4 0130     		adds	r0, r0, #1
 664 02b6 FFF7FEFF 		bl	calloc
 665              	.LVL75:
 271:main.c        **** 
 666              		.loc 1 271 26 discriminator 3 view .LVU230
 667 02ba 48F82900 		str	r0, [r8, r9, lsl #2]
 270:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 668              		.loc 1 270 34 discriminator 3 view .LVU231
 669 02be 09F10109 		add	r9, r9, #1
 670              	.LVL76:
 270:main.c        ****         param->weight[i] = (double**)calloc(layer_sizes[i]+1, sizeof(double*));
 671              		.loc 1 270 34 discriminator 3 view .LVU232
 672 02c2 CBE7     		b	.L26
 673              	.L55:
 674              		.align	2
 675              	.L54:
 676 02c4 00000000 		.word	.LANCHOR0
 677 02c8 00000000 		.word	param
 678 02cc 00000000 		.word	.LC17
 679 02d0 2E000000 		.word	.LC18
 680 02d4 0F010000 		.word	.LC26
 681 02d8 30000000 		.word	.LC19
 682 02dc 73000000 		.word	.LC22
 683 02e0 78000000 		.word	.LC23
 684 02e4 80000000 		.word	.LC24
 685 02e8 B4000000 		.word	.LC25
 686 02ec 5D000000 		.word	.LC20
 687 02f0 C3010000 		.word	.LC29
 688 02f4 66000000 		.word	.LC5
 689 02f8 6E000000 		.word	.LC21
 690 02fc 34010000 		.word	.LC27
 691 0300 68010000 		.word	.LC28
 692 0304 40000000 		.word	.LANCHOR0+64
 693 0308 00000000 		.word	layer_sizes
 694 030c 08010000 		.word	.LANCHOR0+264
 695              	.LVL77:
 696              	.L29:
 276:main.c        **** 
 697              		.loc 1 276 13 is_stmt 1 discriminator 3 view .LVU233
 276:main.c        **** 
 698              		.loc 1 276 29 is_stmt 0 discriminator 3 view .LVU234
 699 0310 1A68     		ldr	r2, [r3]
 276:main.c        **** 
 700              		.loc 1 276 44 discriminator 3 view .LVU235
 701 0312 D9F80400 		ldr	r0, [r9, #4]
 276:main.c        **** 
 702              		.loc 1 276 29 discriminator 3 view .LVU236
 703 0316 0393     		str	r3, [sp, #12]
 276:main.c        **** 
 704              		.loc 1 276 44 discriminator 3 view .LVU237
 705 0318 0821     		movs	r1, #8
 276:main.c        **** 
 706              		.loc 1 276 29 discriminator 3 view .LVU238
 707 031a 0092     		str	r2, [sp]
 276:main.c        **** 
 708              		.loc 1 276 44 discriminator 3 view .LVU239
 709 031c FFF7FEFF 		bl	calloc
 710              	.LVL78:
 276:main.c        **** 
 711              		.loc 1 276 33 discriminator 3 view .LVU240
 712 0320 009A     		ldr	r2, [sp]
 713 0322 039B     		ldr	r3, [sp, #12]
 714 0324 42F82A00 		str	r0, [r2, r10, lsl #2]
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 715              		.loc 1 275 44 discriminator 3 view .LVU241
 716 0328 0AF1010A 		add	r10, r10, #1
 717              	.LVL79:
 718              	.L30:
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 719              		.loc 1 275 9 discriminator 1 view .LVU242
 720 032c D9F80020 		ldr	r2, [r9]
 721 0330 5245     		cmp	r2, r10
 722 0332 EDDA     		bge	.L29
 274:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 723              		.loc 1 274 34 discriminator 2 view .LVU243
 724 0334 0BF1010B 		add	fp, fp, #1
 725              	.LVL80:
 274:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 726              		.loc 1 274 34 discriminator 2 view .LVU244
 727 0338 09F10409 		add	r9, r9, #4
 728 033c 0433     		adds	r3, r3, #4
 729 033e 94E7     		b	.L28
 730              	.LVL81:
 731              	.L46:
 275:main.c        ****             param->weight[i][j] = (double*)calloc(layer_sizes[i+1], sizeof(double));
 732              		.loc 1 275 16 view .LVU245
 733 0340 4FF0000A 		mov	r10, #0
 734 0344 F2E7     		b	.L30
 735              	.LVL82:
 736              	.L32:
 737              	.LBB11:
 738              	.LBB9:
 739              	.LBB7:
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 290:main.c        ****                 param->weight[i][j][k] = weights[weightIndex++];
 740              		.loc 1 290 17 is_stmt 1 discriminator 3 view .LVU246
 741              		.loc 1 290 33 is_stmt 0 discriminator 3 view .LVU247
 742 0346 D8F80030 		ldr	r3, [r8]
 743              		.loc 1 290 40 discriminator 3 view .LVU248
 744 034a 0499     		ldr	r1, [sp, #16]
 745              		.loc 1 290 49 discriminator 3 view .LVU249
 746 034c FEE802AB 		ldrd	r10, [lr], #8
 747              		.loc 1 290 40 discriminator 3 view .LVU250
 748 0350 5958     		ldr	r1, [r3, r1]
 749 0352 01EBC001 		add	r1, r1, r0, lsl #3
 750 0356 C1E900AB 		strd	r10, [r1]
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 751              		.loc 1 289 54 discriminator 3 view .LVU251
 752 035a 0130     		adds	r0, r0, #1
 753              	.LVL83:
 754              	.L34:
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 755              		.loc 1 289 13 discriminator 1 view .LVU252
 756 035c 8145     		cmp	r9, r0
 757 035e F2DC     		bgt	.L32
 758              	.LBE7:
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 759              		.loc 1 288 50 discriminator 2 view .LVU253
 760 0360 009B     		ldr	r3, [sp]
 761 0362 B9F1000F 		cmp	r9, #0
 762 0366 A8BF     		it	ge
 763 0368 CC44     		addge	ip, ip, r9
 764 036a 0133     		adds	r3, r3, #1
 765              	.LVL84:
 766              	.L52:
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 767              		.loc 1 288 50 discriminator 2 view .LVU254
 768 036c 0093     		str	r3, [sp]
 769              	.LVL85:
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 770              		.loc 1 288 9 discriminator 2 view .LVU255
 771 036e 0399     		ldr	r1, [sp, #12]
 772 0370 009B     		ldr	r3, [sp]
 288:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 773              		.loc 1 288 9 discriminator 2 view .LVU256
 774 0372 9942     		cmp	r1, r3
 775 0374 09DB     		blt	.L33
 776              	.LBB8:
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 777              		.loc 1 289 44 view .LVU257
 778 0376 0199     		ldr	r1, [sp, #4]
 779 0378 D1F80090 		ldr	r9, [r1]
 780 037c 9900     		lsls	r1, r3, #2
 781 037e 0491     		str	r1, [sp, #16]
 782 0380 0599     		ldr	r1, [sp, #20]
 289:main.c        ****             for (int k = 0; k < layer_sizes[i + 1]; k++) {
 783              		.loc 1 289 22 view .LVU258
 784 0382 0020     		movs	r0, #0
 785 0384 01EBCC0E 		add	lr, r1, ip, lsl #3
 786 0388 E8E7     		b	.L34
 787              	.L33:
 788              	.LBE8:
 789              	.LBE9:
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 790              		.loc 1 287 40 discriminator 2 view .LVU259
 791 038a 0132     		adds	r2, r2, #1
 792              	.LVL86:
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 793              		.loc 1 287 40 discriminator 2 view .LVU260
 794 038c 08F10408 		add	r8, r8, #4
 795 0390 79E7     		b	.L31
 796              	.LVL87:
 797              	.L35:
 287:main.c        ****         for (int j = 0; j < layer_sizes[i] + 1; j++) {
 798              		.loc 1 287 40 discriminator 2 view .LVU261
 799              	.LBE11:
 291:main.c        ****             }
 292:main.c        ****         }
 293:main.c        ****     }
 294:main.c        **** 
 295:main.c        ****     // Train the neural network on the train data
 296:main.c        ****     // printf("Training:\n");
 297:main.c        ****     // printf("---------\n");
 298:main.c        ****     // mlp_trainer(param, layer_sizes);
 299:main.c        ****     // printf("\nDone.\n\n");
 300:main.c        **** 
 301:main.c        ****     //save the trained weights to a file
 302:main.c        ****     // FILE *fp = fopen("weights.txt", "w");
 303:main.c        ****     // for (i = 0; i < n_layers-1; i++) {
 304:main.c        ****     //     for (j = 0; j < layer_sizes[i]+1; j++) {
 305:main.c        ****     //         for (int k = 0; k < layer_sizes[i+1]; k++) {
 306:main.c        ****     //             fprintf(fp, "%lf ", param->weight[i][j][k]);
 307:main.c        ****     //         }
 308:main.c        ****     //         fprintf(fp, "\n");
 309:main.c        ****     //     }
 310:main.c        ****     //     fprintf(fp, "\n");
 311:main.c        ****     // }
 312:main.c        ****     // fclose(fp);
 313:main.c        **** 
 314:main.c        ****     // Classify the test data using the trained parameter weights
 315:main.c        ****     //printf("Classifying:\n");
 316:main.c        ****     //printf("------------\n");
 317:main.c        ****     uint8_t accuracy = mlp_classifier(param, layer_sizes);
 800              		.loc 1 317 5 is_stmt 1 view .LVU262
 801              		.loc 1 317 24 is_stmt 0 view .LVU263
 802 0392 3946     		mov	r1, r7
 803 0394 2846     		mov	r0, r5
 804 0396 FFF7FEFF 		bl	mlp_classifier
 805              	.LVL88:
 318:main.c        ****     //while(1)
 319:main.c        ****         //simpleserial_get();
 320:main.c        ****     //printf("\nDone.\nOutput file generated\n");
 321:main.c        **** 
 322:main.c        ****     // Free the memory allocated in Heap
 323:main.c        ****     for (i = 0; i < n_layers-1; i++)
 806              		.loc 1 323 12 view .LVU264
 807 039a 0027     		movs	r7, #0
 317:main.c        ****     //while(1)
 808              		.loc 1 317 13 view .LVU265
 809 039c 8DF81B00 		strb	r0, [sp, #27]
 810              		.loc 1 323 5 is_stmt 1 view .LVU266
 811              	.LVL89:
 812              	.L37:
 813              		.loc 1 323 5 is_stmt 0 discriminator 1 view .LVU267
 814 03a0 BE42     		cmp	r6, r7
 815 03a2 4ADB     		blt	.L47
 816 03a4 4FEA8708 		lsl	r8, r7, #2
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 817              		.loc 1 324 16 view .LVU268
 818 03a8 0025     		movs	r5, #0
 819 03aa 06E0     		b	.L40
 820              	.LVL90:
 821              	.L38:
 325:main.c        ****             free(param->weight[i][j]);
 822              		.loc 1 325 13 is_stmt 1 discriminator 3 view .LVU269
 823 03ac 52F80830 		ldr	r3, [r2, r8]
 824 03b0 53F82500 		ldr	r0, [r3, r5, lsl #2]
 825 03b4 FFF7FEFF 		bl	free
 826              	.LVL91:
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 827              		.loc 1 324 44 is_stmt 0 discriminator 3 view .LVU270
 828 03b8 0135     		adds	r5, r5, #1
 829              	.LVL92:
 830              	.L40:
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 831              		.loc 1 324 44 discriminator 3 view .LVU271
 832 03ba 2368     		ldr	r3, [r4]
 833 03bc DA6B     		ldr	r2, [r3, #60]
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 834              		.loc 1 324 23 discriminator 1 view .LVU272
 835 03be 029B     		ldr	r3, [sp, #8]
 836 03c0 1B68     		ldr	r3, [r3]
 324:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 837              		.loc 1 324 9 discriminator 1 view .LVU273
 838 03c2 53F80830 		ldr	r3, [r3, r8]
 839 03c6 AB42     		cmp	r3, r5
 840 03c8 F0DA     		bge	.L38
 323:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 841              		.loc 1 323 34 discriminator 2 view .LVU274
 842 03ca 0137     		adds	r7, r7, #1
 843              	.LVL93:
 323:main.c        ****         for (j = 0; j < layer_sizes[i]+1; j++)
 844              		.loc 1 323 34 discriminator 2 view .LVU275
 845 03cc E8E7     		b	.L37
 846              	.LVL94:
 847              	.L41:
 326:main.c        **** 
 327:main.c        ****     for (i = 0; i < n_layers-1; i++)
 328:main.c        ****         free(param->weight[i]);
 848              		.loc 1 328 9 is_stmt 1 discriminator 3 view .LVU276
 849 03ce 50F82500 		ldr	r0, [r0, r5, lsl #2]
 850 03d2 FFF7FEFF 		bl	free
 851              	.LVL95:
 327:main.c        ****         free(param->weight[i]);
 852              		.loc 1 327 34 is_stmt 0 discriminator 3 view .LVU277
 853 03d6 0135     		adds	r5, r5, #1
 854              	.LVL96:
 855              	.L39:
 327:main.c        ****         free(param->weight[i]);
 856              		.loc 1 327 34 discriminator 3 view .LVU278
 857 03d8 2368     		ldr	r3, [r4]
 327:main.c        ****         free(param->weight[i]);
 858              		.loc 1 327 5 discriminator 1 view .LVU279
 859 03da AE42     		cmp	r6, r5
 860 03dc D86B     		ldr	r0, [r3, #60]
 861 03de F6DA     		bge	.L41
 329:main.c        **** 
 330:main.c        ****     free(param->weight);
 862              		.loc 1 330 5 is_stmt 1 view .LVU280
 863 03e0 FFF7FEFF 		bl	free
 864              	.LVL97:
 331:main.c        **** 
 332:main.c        ****     free(layer_sizes);
 865              		.loc 1 332 5 view .LVU281
 866 03e4 029B     		ldr	r3, [sp, #8]
 867 03e6 1868     		ldr	r0, [r3]
 868 03e8 FFF7FEFF 		bl	free
 869              	.LVL98:
 333:main.c        **** 
 334:main.c        ****     for (i = 0; i < param->train_sample_size; i++)
 870              		.loc 1 334 5 view .LVU282
 871              		.loc 1 334 12 is_stmt 0 view .LVU283
 872 03ec 0025     		movs	r5, #0
 873              	.LVL99:
 874              	.L42:
 875              		.loc 1 334 26 discriminator 1 view .LVU284
 876 03ee 2368     		ldr	r3, [r4]
 877              		.loc 1 334 5 discriminator 1 view .LVU285
 878 03f0 5A6B     		ldr	r2, [r3, #52]
 879 03f2 AA42     		cmp	r2, r5
 880 03f4 23DC     		bgt	.L43
 335:main.c        ****         free(param->data_train[i]);
 336:main.c        **** 
 337:main.c        ****     for (i = 0; i < param->test_sample_size; i++)
 881              		.loc 1 337 12 view .LVU286
 882 03f6 0025     		movs	r5, #0
 883              	.LVL100:
 884              	.L44:
 885              		.loc 1 337 26 discriminator 1 view .LVU287
 886 03f8 2368     		ldr	r3, [r4]
 887              		.loc 1 337 5 discriminator 1 view .LVU288
 888 03fa 9A6B     		ldr	r2, [r3, #56]
 889 03fc AA42     		cmp	r2, r5
 890 03fe 25DC     		bgt	.L45
 338:main.c        ****         free(param->data_test[i]);
 339:main.c        **** 
 340:main.c        ****     free(param->data_train);
 891              		.loc 1 340 5 is_stmt 1 view .LVU289
 892 0400 986A     		ldr	r0, [r3, #40]
 893 0402 FFF7FEFF 		bl	free
 894              	.LVL101:
 341:main.c        ****     free(param->data_test);
 895              		.loc 1 341 5 view .LVU290
 896              		.loc 1 341 15 is_stmt 0 view .LVU291
 897 0406 2368     		ldr	r3, [r4]
 898              		.loc 1 341 5 view .LVU292
 899 0408 D86A     		ldr	r0, [r3, #44]
 900 040a FFF7FEFF 		bl	free
 901              	.LVL102:
 342:main.c        ****     free(param->hidden_activation_functions);
 902              		.loc 1 342 5 is_stmt 1 view .LVU293
 903              		.loc 1 342 15 is_stmt 0 view .LVU294
 904 040e 2368     		ldr	r3, [r4]
 905              		.loc 1 342 5 view .LVU295
 906 0410 9868     		ldr	r0, [r3, #8]
 907 0412 FFF7FEFF 		bl	free
 908              	.LVL103:
 343:main.c        ****     free(param->hidden_layers_size);
 909              		.loc 1 343 5 is_stmt 1 view .LVU296
 910              		.loc 1 343 15 is_stmt 0 view .LVU297
 911 0416 2368     		ldr	r3, [r4]
 912              		.loc 1 343 5 view .LVU298
 913 0418 5868     		ldr	r0, [r3, #4]
 914 041a FFF7FEFF 		bl	free
 915              	.LVL104:
 344:main.c        ****     free(param);
 916              		.loc 1 344 5 is_stmt 1 view .LVU299
 917 041e 2068     		ldr	r0, [r4]
 918 0420 FFF7FEFF 		bl	free
 919              	.LVL105:
 345:main.c        ****     
 346:main.c        ****     
 347:main.c        ****     simpleserial_put('r', 1, (uint8_t*)&accuracy);
 920              		.loc 1 347 5 view .LVU300
 921 0424 0DF11B02 		add	r2, sp, #27
 922 0428 0121     		movs	r1, #1
 923 042a 7220     		movs	r0, #114
 924 042c FFF7FEFF 		bl	simpleserial_put
 925              	.LVL106:
 348:main.c        ****     
 349:main.c        ****     return 0x00;
 926              		.loc 1 349 5 view .LVU301
 350:main.c        **** }
 927              		.loc 1 350 1 is_stmt 0 view .LVU302
 928 0430 0020     		movs	r0, #0
 929 0432 0DF5737D 		add	sp, sp, #972
 930              	.LCFI2:
 931              		.cfi_remember_state
 932              		.cfi_def_cfa_offset 36
 933              		@ sp needed
 934 0436 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 935              	.LVL107:
 936              	.L47:
 937              	.LCFI3:
 938              		.cfi_restore_state
 327:main.c        ****         free(param->weight[i]);
 939              		.loc 1 327 12 view .LVU303
 940 043a 0025     		movs	r5, #0
 941 043c CCE7     		b	.L39
 942              	.LVL108:
 943              	.L43:
 335:main.c        **** 
 944              		.loc 1 335 9 is_stmt 1 discriminator 3 view .LVU304
 945 043e 9B6A     		ldr	r3, [r3, #40]
 946 0440 53F82500 		ldr	r0, [r3, r5, lsl #2]
 947 0444 FFF7FEFF 		bl	free
 948              	.LVL109:
 334:main.c        ****         free(param->data_train[i]);
 949              		.loc 1 334 48 is_stmt 0 discriminator 3 view .LVU305
 950 0448 0135     		adds	r5, r5, #1
 951              	.LVL110:
 334:main.c        ****         free(param->data_train[i]);
 952              		.loc 1 334 48 discriminator 3 view .LVU306
 953 044a D0E7     		b	.L42
 954              	.L45:
 338:main.c        **** 
 955              		.loc 1 338 9 is_stmt 1 discriminator 3 view .LVU307
 956 044c DB6A     		ldr	r3, [r3, #44]
 957 044e 53F82500 		ldr	r0, [r3, r5, lsl #2]
 958 0452 FFF7FEFF 		bl	free
 959              	.LVL111:
 337:main.c        ****         free(param->data_test[i]);
 960              		.loc 1 337 47 is_stmt 0 discriminator 3 view .LVU308
 961 0456 0135     		adds	r5, r5, #1
 962              	.LVL112:
 337:main.c        ****         free(param->data_test[i]);
 963              		.loc 1 337 47 discriminator 3 view .LVU309
 964 0458 CEE7     		b	.L44
 965              		.cfi_endproc
 966              	.LFE3:
 968 045a 00BF     		.section	.text.startup.main,"ax",%progbits
 969              		.align	1
 970              		.global	main
 971              		.syntax unified
 972              		.thumb
 973              		.thumb_func
 974              		.fpu softvfp
 976              	main:
 977              	.LFB4:
 351:main.c        **** 
 352:main.c        **** int main(void) {
 978              		.loc 1 352 16 is_stmt 1 view -0
 979              		.cfi_startproc
 980              		@ Volatile: function does not return.
 981              		@ args = 0, pretend = 0, frame = 0
 982              		@ frame_needed = 0, uses_anonymous_args = 0
 353:main.c        ****     // Initialize UART for serial communication
 354:main.c        ****     platform_init();
 983              		.loc 1 354 5 view .LVU311
 352:main.c        ****     // Initialize UART for serial communication
 984              		.loc 1 352 16 is_stmt 0 view .LVU312
 985 0000 08B5     		push	{r3, lr}
 986              	.LCFI4:
 987              		.cfi_def_cfa_offset 8
 988              		.cfi_offset 3, -8
 989              		.cfi_offset 14, -4
 990              		.loc 1 354 5 view .LVU313
 991 0002 FFF7FEFF 		bl	platform_init
 992              	.LVL113:
 355:main.c        ****     init_uart();
 993              		.loc 1 355 5 is_stmt 1 view .LVU314
 994 0006 FFF7FEFF 		bl	init_uart
 995              	.LVL114:
 356:main.c        ****     trigger_setup();
 996              		.loc 1 356 5 view .LVU315
 997 000a FFF7FEFF 		bl	trigger_setup
 998              	.LVL115:
 357:main.c        ****     simpleserial_init();
 999              		.loc 1 357 5 view .LVU316
 1000 000e FFF7FEFF 		bl	simpleserial_init
 1001              	.LVL116:
 358:main.c        **** 
 359:main.c        ****     // Add a command to the SimpleSerial module
 360:main.c        ****     simpleserial_addcmd('a', 0, mlp);
 1002              		.loc 1 360 5 view .LVU317
 1003 0012 044A     		ldr	r2, .L58
 1004 0014 0021     		movs	r1, #0
 1005 0016 6120     		movs	r0, #97
 1006 0018 FFF7FEFF 		bl	simpleserial_addcmd
 1007              	.LVL117:
 1008              	.L57:
 361:main.c        ****     //put some value so we can verify if we cna read them.
 362:main.c        **** 
 363:main.c        ****     for (;;)
 1009              		.loc 1 363 5 discriminator 1 view .LVU318
 364:main.c        ****     {
 365:main.c        ****         simpleserial_get();
 1010              		.loc 1 365 9 discriminator 1 view .LVU319
 1011 001c FFF7FEFF 		bl	simpleserial_get
 1012              	.LVL118:
 1013 0020 FCE7     		b	.L57
 1014              	.L59:
 1015 0022 00BF     		.align	2
 1016              	.L58:
 1017 0024 00000000 		.word	mlp
 1018              		.cfi_endproc
 1019              	.LFE4:
 1021              		.comm	layer_sizes,4,4
 1022              		.comm	param,4,4
 1023              		.section	.rodata
 1024              		.align	3
 1025              		.set	.LANCHOR0,. + 0
 1026              	.LC16:
 1027 0000 F6010000 		.word	.LC0
 1028 0004 06020000 		.word	.LC1
 1029 0008 08020000 		.word	.LC2
 1030 000c 0E020000 		.word	.LC3
 1031 0010 20020000 		.word	.LC4
 1032 0014 66000000 		.word	.LC5
 1033 0018 22020000 		.word	.LC6
 1034 001c 27020000 		.word	.LC7
 1035 0020 2E020000 		.word	.LC8
 1036 0024 42020000 		.word	.LC9
 1037 0028 47020000 		.word	.LC10
 1038 002c 49020000 		.word	.LC11
 1039 0030 5C020000 		.word	.LC12
 1040 0034 47020000 		.word	.LC10
 1041 0038 00000000 		.word	0
 1042 003c 00000000 		.space	4
 1043              	.LC14:
 1044 0040 6F1283C0 		.word	3229815407
 1045 0044 CAA1F93F 		.word	1073324490
 1046 0048 1CEBE236 		.word	920840988
 1047 004c 1A801840 		.word	1075347482
 1048 0050 728577B9 		.word	3111617906
 1049 0054 88EFE03F 		.word	1071705992
 1050 0058 3134D769 		.word	1775711281
 1051 005c A4A5DE3F 		.word	1071556004
 1052 0060 00000000 		.word	0
 1053 0064 00000000 		.word	0
 1054 0068 4BC8073D 		.word	1023920203
 1055 006c 9B5502C0 		.word	-1073588837
 1056 0070 BC490C02 		.word	34359740
 1057 0074 2B071DC0 		.word	-1071839445
 1058 0078 82E2C798 		.word	2563236482
 1059 007c BBD61F40 		.word	1075828411
 1060 0080 280F0BB5 		.word	3037400872
 1061 0084 A679ED3F 		.word	1072527782
 1062 0088 00000000 		.word	0
 1063 008c 0000F03F 		.word	1072693248
 1064 0090 5F6397A8 		.word	2828493663
 1065 0094 DE1AE6BF 		.word	-1075438882
 1066 0098 662C9ACE 		.word	3466210406
 1067 009c 4E06E0BF 		.word	-1075837362
 1068 00a0 425BCEA5 		.word	2781764418
 1069 00a4 B8AAD6BF 		.word	-1076450632
 1070 00a8 D9429083 		.word	2207269593
 1071 00ac 1266DE3F 		.word	1071539730
 1072 00b0 00000000 		.word	0
 1073 00b4 0000F03F 		.word	1072693248
 1074 00b8 C66D3480 		.word	2150919622
 1075 00bc B740FA3F 		.word	1073365175
 1076 00c0 55C1A8A4 		.word	2762522965
 1077 00c4 4E001140 		.word	1074856014
 1078 00c8 24B9FC87 		.word	2281486628
 1079 00cc F49B13C0 		.word	-1072456716
 1080 00d0 EB73B515 		.word	364213227
 1081 00d4 FB4B05C0 		.word	-1073394693
 1082 00d8 00000000 		.word	0
 1083 00dc 0000F03F 		.word	1072693248
 1084 00e0 04560E2D 		.word	755914244
 1085 00e4 B29D0C40 		.word	1074568626
 1086 00e8 158C4AEA 		.word	3930754069
 1087 00ec 04340340 		.word	1073951748
 1088 00f0 C66D3480 		.word	2150919622
 1089 00f4 B740FE3F 		.word	1073627319
 1090 00f8 90149161 		.word	1636897936
 1091 00fc 156FE73F 		.word	1072131861
 1092 0100 00000000 		.word	0
 1093 0104 00000000 		.word	0
 1094              	.LC15:
 1095 0108 0AF4893C 		.word	1015673866
 1096 010c 493AE73F 		.word	1072118345
 1097 0110 0D6D0036 		.word	905997581
 1098 0114 2042DC3F 		.word	1071399456
 1099 0118 A779C729 		.word	700938663
 1100 011c 3A92E9BF 		.word	-1075211718
 1101 0120 EDD63219 		.word	422762221
 1102 0124 8EE7833F 		.word	1065609102
 1103 0128 B83EAC37 		.word	934035128
 1104 012c 6A85DC3F 		.word	1071416682
 1105 0130 8CF4A276 		.word	1990390924
 1106 0134 BF0AE3BF 		.word	-1075639617
 1107 0138 CD57C9C7 		.word	3351861197
 1108 013c EE02D0BF 		.word	-1076886802
 1109 0140 E3512AE1 		.word	3777647075
 1110 0144 09BDCA3F 		.word	1070251273
 1111 0148 8A5B0531 		.word	822434698
 1112 014c D0B5D13F 		.word	1070708176
 1113 0150 88467710 		.word	276252296
 1114 0154 3B53C83F 		.word	1070093115
 1115 0158 1A14CD03 		.word	63771674
 1116 015c 58E4A7BF 		.word	-1079516072
 1117 0160 09F9A067 		.word	1738602761
 1118 0164 B36AE83F 		.word	1072196275
 1119 0168 310A82C7 		.word	3347188273
 1120 016c B777CBBF 		.word	-1077184585
 1121 0170 CC96AC8A 		.word	2326566604
 1122 0174 7093D9BF 		.word	-1076259984
 1123 0178 B950F9D7 		.word	3623440569
 1124 017c F2CAE7BF 		.word	-1075328270
 1125 0180 9544F641 		.word	1106658453
 1126 0184 9685E73F 		.word	1072137622
 1127 0188 8EACFC32 		.word	855420046
 1128 018c 1823CA3F 		.word	1070211864
 1129 0190 AAD72D02 		.word	36558762
 1130 0194 637DE0BF 		.word	-1075806877
 1131 0198 8AE942AC 		.word	2890066314
 1132 019c FE88E43F 		.word	1071941886
 1133 01a0 F8E28BF6 		.word	4136362744
 1134 01a4 7821D1BF 		.word	-1076813448
 1135 01a8 81CB63CD 		.word	3445869441
 1136 01ac C820873F 		.word	1065820360
 1137 01b0 6F46CD57 		.word	1473070703
 1138 01b4 C9C7CE3F 		.word	1070516169
 1139 01b8 FAB83654 		.word	1412872442
 1140 01bc 8CF3DC3F 		.word	1071444876
 1141 01c0 0F43AB93 		.word	2477474575
 1142 01c4 3314C33F 		.word	1069749299
 1143 01c8 842C0B26 		.word	638266500
 1144 01cc FE28DEBF 		.word	-1075959554
 1145 01d0 F8FC3042 		.word	1110506744
 1146 01d4 78B4E23F 		.word	1071821944
 1147 01d8 344C6DA9 		.word	2842512436
 1148 01dc 83BCCABF 		.word	-1077232509
 1149 01e0 B3976DA7 		.word	2808977331
 1150 01e4 AD11D6BF 		.word	-1076489811
 1151 01e8 C05FCC96 		.word	2529976256
 1152 01ec AC8AC43F 		.word	1069845164
 1153 01f0 14048F6F 		.word	1871643668
 1154 01f4 EF1AA43F 		.word	1067719407
 1155 01f8 4791B586 		.word	2260046151
 1156 01fc 52FBE53F 		.word	1072036690
 1157 0200 08C89750 		.word	1352124424
 1158 0204 C1E1B13F 		.word	1068622273
 1159 0208 62D8614C 		.word	1281480802
 1160 020c FA7BD5BF 		.word	-1076528134
 1161 0210 B01EF7AD 		.word	2918653616
 1162 0214 D689E63F 		.word	1072073174
 1163 0218 B34291EE 		.word	4002497203
 1164 021c E794E7BF 		.word	-1075342105
 1165 0220 E5D3635B 		.word	1533268965
 1166 0224 069CE6BF 		.word	-1075405818
 1167 0228 ECDCB419 		.word	431283436
 1168 022c A7A1E6BF 		.word	-1075404377
 1169 0230 289EB305 		.word	95657512
 1170 0234 84D6C5BF 		.word	-1077553532
 1171 0238 478FDFDB 		.word	3688861511
 1172 023c F467D43F 		.word	1070884852
 1173 0240 D1AFAD9F 		.word	2678960081
 1174 0244 FEB3D83F 		.word	1071166462
 1175 0248 F81C588E 		.word	2388139256
 1176 024c 9081E9BF 		.word	-1075215984
 1177 0250 AE105663 		.word	1666584750
 1178 0254 096BE1BF 		.word	-1075746039
 1179 0258 C493DDCC 		.word	3437073348
 1180 025c E847D53F 		.word	1070942184
 1181 0260 D061BEBC 		.word	3166593488
 1182 0264 00FBC8BF 		.word	-1077347584
 1183 0268 11548D5E 		.word	1586320401
 1184 026c 0D50C0BF 		.word	-1077915635
 1185 0270 7100FDBE 		.word	3204251761
 1186 0274 7FF3D93F 		.word	1071248255
 1187 0278 AFCDC64A 		.word	1254542767
 1188 027c CCB3D1BF 		.word	-1076775988
 1189 0280 DA3C0E83 		.word	2198748378
 1190 0284 F9ABE7BF 		.word	-1075336199
 1191 0288 88BB7A15 		.word	360364936
 1192 028c 199DE63F 		.word	1072078105
 1193 0290 807D74EA 		.word	3933502848
 1194 0294 CA67DBBF 		.word	-1076140086
 1195 0298 4CC45BE7 		.word	3881550924
 1196 029c DF2EC7BF 		.word	-1077465377
 1197 02a0 BAD91F28 		.word	673175994
 1198 02a4 B7EDB7BF 		.word	-1078465097
 1199 02a8 95D39E92 		.word	2459882389
 1200 02ac 7362E23F 		.word	1071800947
 1201 02b0 A51309A6 		.word	2785612709
 1202 02b4 9AD9E0BF 		.word	-1075783270
 1203 02b8 D7DEA7AA 		.word	2863128279
 1204 02bc D040E7BF 		.word	-1075363632
 1205 02c0 5D8B16A0 		.word	2685832029
 1206 02c4 6DB5E4BF 		.word	-1075530387
 1207 02c8 48FC8A35 		.word	898301000
 1208 02cc 5CE4E7BF 		.word	-1075321764
 1209 02d0 CB82893F 		.word	1065976523
 1210 02d4 8A3AC3BF 		.word	-1077724534
 1211 02d8 F6984869 		.word	1766365430
 1212 02dc 368FC9BF 		.word	-1077309642
 1213 02e0 257497C4 		.word	3298260005
 1214 02e4 5911C73F 		.word	1070010713
 1215 02e8 79E92631 		.word	824633721
 1216 02ec 082CE53F 		.word	1071983624
 1217 02f0 C3F2E7DB 		.word	3689411267
 1218 02f4 82A5D4BF 		.word	-1076583038
 1219 02f8 56F5F23B 		.word	1005778262
 1220 02fc 4DE6E0BF 		.word	-1075780019
 1221 0300 D33252EF 		.word	4015141587
 1222 0304 A99CDBBF 		.word	-1076126551
 1223 0308 E0641BB8 		.word	3088803040
 1224 030c 0375DBBF 		.word	-1076136701
 1225 0310 8657923C 		.word	1016223622
 1226 0314 D7F7DCBF 		.word	-1076037673
 1227 0318 0CAF2479 		.word	2032447244
 1228 031c AEEFD4BF 		.word	-1076564050
 1229 0320 C24CDBBF 		.word	3218820290
 1230 0324 B2D2D4BF 		.word	-1076571470
 1231 0328 B37DC85B 		.word	1539866035
 1232 032c AE7EC43F 		.word	1069842094
 1233 0330 A647533D 		.word	1028868006
 1234 0334 99FFE73F 		.word	1072168857
 1235 0338 F8C61000 		.word	1099512
 1236 033c 1C7BE7BF 		.word	-1075348708
 1237 0340 D0B359F5 		.word	4116296656
 1238 0344 B9DAC63F 		.word	1069996729
 1239 0348 B000A60C 		.word	212205744
 1240 034c 1C50E1BF 		.word	-1075752932
 1241 0350 5AF0A2AF 		.word	2946691162
 1242 0354 20CDD63F 		.word	1071041824
 1243 0358 276728EE 		.word	3995625255
 1244 035c 7893E83F 		.word	1072206712
 1245 0360 0F62670A 		.word	174547471
 1246 0364 9DD7BC3F 		.word	1069340573
 1247 0368 4ED02687 		.word	2267467854
 1248 036c 4F3AA1BF 		.word	-1079952817
 1249 0370 9EEFA7C6 		.word	3332894622
 1250 0374 4B37D1BF 		.word	-1076807861
 1251 0378 E2218C9F 		.word	2676761058
 1252 037c C6BDC73F 		.word	1070054854
 1253 0380 6B0BCF4B 		.word	1271860075
 1254 0384 C5C6C6BF 		.word	-1077492027
 1255 0388 8237A451 		.word	1369716610
 1256 038c 8193B93F 		.word	1069126529
 1257 0390 E0F3C308 		.word	147059680
 1258 0394 E1D1EFBF 		.word	-1074802207
 1259 0398 CAC51858 		.word	1478018506
 1260 039c C771E63F 		.word	1072067015
 1261 03a0 782975C9 		.word	3379898744
 1262 03a4 3846C4BF 		.word	-1077656008
 1263 03a8 FBAE08FE 		.word	4261981947
 1264 03ac B792E5BF 		.word	-1075473737
 1265              		.section	.rodata.str1.1,"aMS",%progbits,1
 1266              	.LC17:
 1267 0000 4572726F 		.ascii	"Error: Number of hidden layers should be >= 0\000"
 1267      723A204E 
 1267      756D6265 
 1267      72206F66 
 1267      20686964 
 1268              	.LC18:
 1269 002e 2C00     		.ascii	",\000"
 1270              	.LC19:
 1271 0030 4572726F 		.ascii	"Error: Hidden layer sizes should be positive\000"
 1271      723A2048 
 1271      69646465 
 1271      6E206C61 
 1271      79657220 
 1272              	.LC20:
 1273 005d 6964656E 		.ascii	"identity\000"
 1273      74697479 
 1273      00
 1274              	.LC5:
 1275 0066 7369676D 		.ascii	"sigmoid\000"
 1275      6F696400 
 1276              	.LC21:
 1277 006e 74616E68 		.ascii	"tanh\000"
 1277      00
 1278              	.LC22:
 1279 0073 72656C75 		.ascii	"relu\000"
 1279      00
 1280              	.LC23:
 1281 0078 736F6674 		.ascii	"softmax\000"
 1281      6D617800 
 1282              	.LC24:
 1283 0080 4572726F 		.ascii	"Error: Invalid value for hidden activation function"
 1283      723A2049 
 1283      6E76616C 
 1283      69642076 
 1283      616C7565 
 1284 00b3 00       		.ascii	"\000"
 1285              	.LC25:
 1286 00b4 496E7075 		.ascii	"Input either identity or sigmoid or tanh or relu or"
 1286      74206569 
 1286      74686572 
 1286      20696465 
 1286      6E746974 
 1287 00e7 20736F66 		.ascii	" softmax for hidden activation function\000"
 1287      746D6178 
 1287      20666F72 
 1287      20686964 
 1287      64656E20 
 1288              	.LC26:
 1289 010f 4F757470 		.ascii	"Output layer size should be positive\000"
 1289      7574206C 
 1289      61796572 
 1289      2073697A 
 1289      65207368 
 1290              	.LC27:
 1291 0134 4572726F 		.ascii	"Error: Invalid value for output activation function"
 1291      723A2049 
 1291      6E76616C 
 1291      69642076 
 1291      616C7565 
 1292 0167 00       		.ascii	"\000"
 1293              	.LC28:
 1294 0168 496E7075 		.ascii	"Input either identity or sigmoid or tanh or relu or"
 1294      74206569 
 1294      74686572 
 1294      20696465 
 1294      6E746974 
 1295 019b 20736F66 		.ascii	" softmax for output activation function\000"
 1295      746D6178 
 1295      20666F72 
 1295      206F7574 
 1295      70757420 
 1296              	.LC29:
 1297 01c3 4D61782E 		.ascii	"Max. number of iterations value should be positive\000"
 1297      206E756D 
 1297      62657220 
 1297      6F662069 
 1297      74657261 
 1298              	.LC0:
 1299 01f6 65786563 		.ascii	"executable_name\000"
 1299      75746162 
 1299      6C655F6E 
 1299      616D6500 
 1300              	.LC1:
 1301 0206 3300     		.ascii	"3\000"
 1302              	.LC2:
 1303 0208 342C352C 		.ascii	"4,5,5\000"
 1303      3500
 1304              	.LC3:
 1305 020e 736F6674 		.ascii	"softmax,relu,tanh\000"
 1305      6D61782C 
 1305      72656C75 
 1305      2C74616E 
 1305      6800
 1306              	.LC4:
 1307 0220 3100     		.ascii	"1\000"
 1308              	.LC6:
 1309 0222 302E3031 		.ascii	"0.01\000"
 1309      00
 1310              	.LC7:
 1311 0227 31303030 		.ascii	"10000 \000"
 1311      302000
 1312              	.LC8:
 1313 022e 64617461 		.ascii	"data/data_train.csv\000"
 1313      2F646174 
 1313      615F7472 
 1313      61696E2E 
 1313      63737600 
 1314              	.LC9:
 1315 0242 31303936 		.ascii	"1096\000"
 1315      00
 1316              	.LC10:
 1317 0247 3500     		.ascii	"5\000"
 1318              	.LC11:
 1319 0249 64617461 		.ascii	"data/data_test.csv\000"
 1319      2F646174 
 1319      615F7465 
 1319      73742E63 
 1319      737600
 1320              	.LC12:
 1321 025c 32373500 		.ascii	"275\000"
 1322              		.text
 1323              	.Letext0:
 1324              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1325              		.file 3 "/usr/lib/gcc/arm-none-eabi/8.3.1/include/stddef.h"
 1326              		.file 4 "/usr/include/newlib/sys/_types.h"
 1327              		.file 5 "/usr/include/newlib/sys/reent.h"
 1328              		.file 6 "/usr/include/newlib/sys/lock.h"
 1329              		.file 7 "/usr/include/newlib/sys/_stdint.h"
 1330              		.file 8 "/usr/include/newlib/stdlib.h"
 1331              		.file 9 "/usr/include/newlib/math.h"
 1332              		.file 10 "parameters.h"
 1333              		.file 11 "hal.h"
 1334              		.file 12 "../hardware/victims/firmware/hal/stm32f3/stm32f3_hal.h"
 1335              		.file 13 "simpleserial.h"
 1336              		.file 14 "/usr/include/newlib/string.h"
 1337              		.file 15 "<built-in>"
 1338              		.file 16 "mlp_classifier.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccMHLLbB.s:17     .text.mlp:0000000000000000 $t
     /tmp/ccMHLLbB.s:25     .text.mlp:0000000000000000 mlp
     /tmp/ccMHLLbB.s:676    .text.mlp:00000000000002c4 $d
                            *COM*:0000000000000004 param
                            *COM*:0000000000000004 layer_sizes
     /tmp/ccMHLLbB.s:699    .text.mlp:0000000000000310 $t
     /tmp/ccMHLLbB.s:969    .text.startup.main:0000000000000000 $t
     /tmp/ccMHLLbB.s:976    .text.startup.main:0000000000000000 main
     /tmp/ccMHLLbB.s:1017   .text.startup.main:0000000000000024 $d
     /tmp/ccMHLLbB.s:1024   .rodata:0000000000000000 $d

UNDEFINED SYMBOLS
__aeabi_i2d
malloc
strlen
strcpy
atoi
puts
exit
strtok
strcmp
memcpy
calloc
mlp_classifier
free
simpleserial_put
platform_init
init_uart
trigger_setup
simpleserial_init
simpleserial_addcmd
simpleserial_get
