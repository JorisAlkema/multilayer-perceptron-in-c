   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"mlp_trainer.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_i2d
  16              		.global	__aeabi_ddiv
  17              		.global	__aeabi_dadd
  18              		.global	__aeabi_dsub
  19              		.section	.text.initialize_weights,"ax",%progbits
  20              		.align	1
  21              		.global	initialize_weights
  22              		.arch armv7e-m
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  26              		.fpu softvfp
  28              	initialize_weights:
  29              	.LVL0:
  30              	.LFB3:
  31              		.file 1 "mlp_trainer.c"
   1:mlp_trainer.c **** /*
   2:mlp_trainer.c **** Author: Manohar Mukku
   3:mlp_trainer.c **** Date: 20.07.2018
   4:mlp_trainer.c **** Desc: Train the parameter weights on the train data set
   5:mlp_trainer.c **** GitHub: https://github.com/manoharmukku/multilayer-perceptron-in-c
   6:mlp_trainer.c **** */
   7:mlp_trainer.c **** 
   8:mlp_trainer.c **** #include "mlp_trainer.h"
   9:mlp_trainer.c **** 
  10:mlp_trainer.c **** void initialize_weights(parameters* param, int n_layers, int* layer_sizes) {
  32              		.loc 1 10 76 view -0
  33              		.cfi_startproc
  34              		@ args = 0, pretend = 0, frame = 32
  35              		@ frame_needed = 0, uses_anonymous_args = 0
  11:mlp_trainer.c ****     srand(time(0));
  36              		.loc 1 11 5 view .LVU1
  10:mlp_trainer.c ****     srand(time(0));
  37              		.loc 1 10 76 is_stmt 0 view .LVU2
  38 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  39              	.LCFI0:
  40              		.cfi_def_cfa_offset 36
  41              		.cfi_offset 4, -36
  42              		.cfi_offset 5, -32
  43              		.cfi_offset 6, -28
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 8, -20
  46              		.cfi_offset 9, -16
  47              		.cfi_offset 10, -12
  48              		.cfi_offset 11, -8
  49              		.cfi_offset 14, -4
  50 0004 89B0     		sub	sp, sp, #36
  51              	.LCFI1:
  52              		.cfi_def_cfa_offset 72
  10:mlp_trainer.c ****     srand(time(0));
  53              		.loc 1 10 76 view .LVU3
  54 0006 0D46     		mov	r5, r1
  55 0008 0490     		str	r0, [sp, #16]
  56              		.loc 1 11 11 view .LVU4
  57 000a 0020     		movs	r0, #0
  58              	.LVL1:
  10:mlp_trainer.c ****     srand(time(0));
  59              		.loc 1 10 76 view .LVU5
  60 000c 1446     		mov	r4, r2
  12:mlp_trainer.c **** 
  13:mlp_trainer.c ****     // epsilon = sqrt(6/(layer_size[i] + layer_size[i+1])) used for random initialization
  14:mlp_trainer.c ****     double* epsilon = (double*)calloc(n_layers-1, sizeof(double));
  61              		.loc 1 14 47 view .LVU6
  62 000e 013D     		subs	r5, r5, #1
  11:mlp_trainer.c **** 
  63              		.loc 1 11 11 view .LVU7
  64 0010 FFF7FEFF 		bl	time
  65              	.LVL2:
  11:mlp_trainer.c **** 
  66              		.loc 1 11 5 view .LVU8
  67 0014 FFF7FEFF 		bl	srand
  68              	.LVL3:
  69              		.loc 1 14 5 is_stmt 1 view .LVU9
  70              		.loc 1 14 32 is_stmt 0 view .LVU10
  71 0018 0821     		movs	r1, #8
  72 001a 2846     		mov	r0, r5
  73 001c FFF7FEFF 		bl	calloc
  74              	.LVL4:
  15:mlp_trainer.c ****     int i;
  16:mlp_trainer.c ****     for (i = 0; i < n_layers-1; i++)
  17:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
  75              		.loc 1 17 22 view .LVU11
  76 0020 DFF8E490 		ldr	r9, .L10+8
  14:mlp_trainer.c ****     int i;
  77              		.loc 1 14 32 view .LVU12
  78 0024 0646     		mov	r6, r0
  79              	.LVL5:
  15:mlp_trainer.c ****     int i;
  80              		.loc 1 15 5 is_stmt 1 view .LVU13
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
  81              		.loc 1 16 5 view .LVU14
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
  82              		.loc 1 16 5 is_stmt 0 view .LVU15
  83 0026 A0F1080B 		sub	fp, r0, #8
  84 002a A246     		mov	r10, r4
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
  85              		.loc 1 16 12 view .LVU16
  86 002c 0027     		movs	r7, #0
  87              		.loc 1 17 22 view .LVU17
  88 002e 4FF00008 		mov	r8, #0
  89              	.LVL6:
  90              	.L2:
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
  91              		.loc 1 16 17 is_stmt 1 discriminator 1 view .LVU18
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
  92              		.loc 1 16 5 is_stmt 0 discriminator 1 view .LVU19
  93 0032 BD42     		cmp	r5, r7
  94 0034 09DC     		bgt	.L3
  95 0036 0196     		str	r6, [sp, #4]
  18:mlp_trainer.c **** 
  19:mlp_trainer.c ****     // Random initialization between [-epsilon[i], epsilon[i]] for weight[i]
  20:mlp_trainer.c ****     int j, k;
  21:mlp_trainer.c ****     for (i = 0; i < n_layers-1; i++)
  96              		.loc 1 21 12 view .LVU20
  97 0038 4FF00008 		mov	r8, #0
  98              	.LVL7:
  99              	.L4:
 100              		.loc 1 21 17 is_stmt 1 discriminator 1 view .LVU21
 101              		.loc 1 21 5 is_stmt 0 discriminator 1 view .LVU22
 102 003c 4545     		cmp	r5, r8
 103 003e 58DD     		ble	.L8
 104 0040 4FEA8803 		lsl	r3, r8, #2
 105 0044 0393     		str	r3, [sp, #12]
  22:mlp_trainer.c ****         for (j = 0; j < layer_sizes[i]+1; j++)
 106              		.loc 1 22 16 view .LVU23
 107 0046 0027     		movs	r7, #0
 108 0048 44E0     		b	.L9
 109              	.LVL8:
 110              	.L3:
  17:mlp_trainer.c **** 
 111              		.loc 1 17 9 is_stmt 1 discriminator 3 view .LVU24
  17:mlp_trainer.c **** 
 112              		.loc 1 17 45 is_stmt 0 discriminator 3 view .LVU25
 113 004a DAF80000 		ldr	r0, [r10]
  17:mlp_trainer.c **** 
 114              		.loc 1 17 49 discriminator 3 view .LVU26
 115 004e 5AF8043F 		ldr	r3, [r10, #4]!
  17:mlp_trainer.c **** 
 116              		.loc 1 17 22 discriminator 3 view .LVU27
 117 0052 1844     		add	r0, r0, r3
 118 0054 FFF7FEFF 		bl	__aeabi_i2d
 119              	.LVL9:
 120 0058 0246     		mov	r2, r0
 121 005a 0B46     		mov	r3, r1
 122 005c 4046     		mov	r0, r8
 123 005e 4946     		mov	r1, r9
 124 0060 FFF7FEFF 		bl	__aeabi_ddiv
 125              	.LVL10:
 126 0064 FFF7FEFF 		bl	sqrt
 127              	.LVL11:
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
 128              		.loc 1 16 34 discriminator 3 view .LVU28
 129 0068 0137     		adds	r7, r7, #1
 130              	.LVL12:
  17:mlp_trainer.c **** 
 131              		.loc 1 17 20 discriminator 3 view .LVU29
 132 006a EBE90201 		strd	r0, [fp, #8]!
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
 133              		.loc 1 16 33 is_stmt 1 discriminator 3 view .LVU30
 134              	.LVL13:
  16:mlp_trainer.c ****         epsilon[i] = sqrt(6.0 / (layer_sizes[i] + layer_sizes[i+1]));
 135              		.loc 1 16 33 is_stmt 0 discriminator 3 view .LVU31
 136 006e E0E7     		b	.L2
 137              	.LVL14:
 138              	.L5:
  23:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
  24:mlp_trainer.c ****                 param->weight[i][j][k] = -epsilon[i] + ((double)rand() / ((double)RAND_MAX / (2.0 *
 139              		.loc 1 24 17 is_stmt 1 discriminator 3 view .LVU32
 140              		.loc 1 24 65 is_stmt 0 discriminator 3 view .LVU33
 141 0070 FFF7FEFF 		bl	rand
 142              	.LVL15:
 143              		.loc 1 24 108 discriminator 3 view .LVU34
 144 0074 019B     		ldr	r3, [sp, #4]
 145              		.loc 1 24 33 discriminator 3 view .LVU35
 146 0076 039A     		ldr	r2, [sp, #12]
 147              		.loc 1 24 108 discriminator 3 view .LVU36
 148 0078 D3E900AB 		ldrd	r10, [r3]
 149              		.loc 1 24 30 discriminator 3 view .LVU37
 150 007c 049B     		ldr	r3, [sp, #16]
 151 007e DB6B     		ldr	r3, [r3, #60]
 152              		.loc 1 24 33 discriminator 3 view .LVU38
 153 0080 9B58     		ldr	r3, [r3, r2]
 154              		.loc 1 24 40 discriminator 3 view .LVU39
 155 0082 029A     		ldr	r2, [sp, #8]
 156 0084 9B58     		ldr	r3, [r3, r2]
 157 0086 03EBC903 		add	r3, r3, r9, lsl #3
 158 008a 0593     		str	r3, [sp, #20]
 159              		.loc 1 24 57 discriminator 3 view .LVU40
 160 008c FFF7FEFF 		bl	__aeabi_i2d
 161              	.LVL16:
 162              		.loc 1 24 99 discriminator 3 view .LVU41
 163 0090 5246     		mov	r2, r10
 164              		.loc 1 24 57 discriminator 3 view .LVU42
 165 0092 CDE90601 		strd	r0, [sp, #24]
 166              		.loc 1 24 99 discriminator 3 view .LVU43
 167 0096 5B46     		mov	r3, fp
 168 0098 5046     		mov	r0, r10
 169 009a 5946     		mov	r1, fp
 170 009c FFF7FEFF 		bl	__aeabi_dadd
 171              	.LVL17:
 172 00a0 0246     		mov	r2, r0
 173 00a2 0B46     		mov	r3, r1
 174              		.loc 1 24 92 discriminator 3 view .LVU44
 175 00a4 16A1     		adr	r1, .L10
 176 00a6 D1E90001 		ldrd	r0, [r1]
 177 00aa FFF7FEFF 		bl	__aeabi_ddiv
 178              	.LVL18:
 179 00ae 0246     		mov	r2, r0
 180 00b0 0B46     		mov	r3, r1
 181              		.loc 1 24 72 discriminator 3 view .LVU45
 182 00b2 DDE90601 		ldrd	r0, [sp, #24]
 183 00b6 FFF7FEFF 		bl	__aeabi_ddiv
 184              	.LVL19:
 185              		.loc 1 24 54 discriminator 3 view .LVU46
 186 00ba 5B46     		mov	r3, fp
 187 00bc 5246     		mov	r2, r10
 188 00be FFF7FEFF 		bl	__aeabi_dsub
 189              	.LVL20:
 190              		.loc 1 24 40 discriminator 3 view .LVU47
 191 00c2 059B     		ldr	r3, [sp, #20]
 192 00c4 C3E90001 		strd	r0, [r3]
  23:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 193              		.loc 1 23 47 is_stmt 1 discriminator 3 view .LVU48
  23:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 194              		.loc 1 23 48 is_stmt 0 discriminator 3 view .LVU49
 195 00c8 09F10109 		add	r9, r9, #1
 196              	.LVL21:
 197              	.L7:
  23:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 198              		.loc 1 23 25 is_stmt 1 discriminator 1 view .LVU50
  23:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 199              		.loc 1 23 13 is_stmt 0 discriminator 1 view .LVU51
 200 00cc 6368     		ldr	r3, [r4, #4]
 201 00ce 4B45     		cmp	r3, r9
 202 00d0 CEDC     		bgt	.L5
  22:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 203              		.loc 1 22 43 is_stmt 1 discriminator 2 view .LVU52
  22:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 204              		.loc 1 22 44 is_stmt 0 discriminator 2 view .LVU53
 205 00d2 0137     		adds	r7, r7, #1
 206              	.LVL22:
 207              	.L9:
  22:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 208              		.loc 1 22 21 is_stmt 1 discriminator 1 view .LVU54
  22:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 209              		.loc 1 22 9 is_stmt 0 discriminator 1 view .LVU55
 210 00d4 2368     		ldr	r3, [r4]
 211 00d6 BB42     		cmp	r3, r7
 212 00d8 04DB     		blt	.L6
 213 00da BB00     		lsls	r3, r7, #2
 214 00dc 0293     		str	r3, [sp, #8]
  23:mlp_trainer.c ****             for (k = 0; k < layer_sizes[i+1]; k++)
 215              		.loc 1 23 20 view .LVU56
 216 00de 4FF00009 		mov	r9, #0
 217 00e2 F3E7     		b	.L7
 218              	.L6:
  21:mlp_trainer.c ****         for (j = 0; j < layer_sizes[i]+1; j++)
 219              		.loc 1 21 33 is_stmt 1 discriminator 2 view .LVU57
 220 00e4 019B     		ldr	r3, [sp, #4]
 221 00e6 0833     		adds	r3, r3, #8
  21:mlp_trainer.c ****         for (j = 0; j < layer_sizes[i]+1; j++)
 222              		.loc 1 21 34 is_stmt 0 discriminator 2 view .LVU58
 223 00e8 08F10108 		add	r8, r8, #1
 224              	.LVL23:
  21:mlp_trainer.c ****         for (j = 0; j < layer_sizes[i]+1; j++)
 225              		.loc 1 21 34 discriminator 2 view .LVU59
 226 00ec 0434     		adds	r4, r4, #4
 227 00ee 0193     		str	r3, [sp, #4]
 228 00f0 A4E7     		b	.L4
 229              	.LVL24:
 230              	.L8:
  25:mlp_trainer.c **** 
  26:mlp_trainer.c ****     // Free the memory allocated in Heap for epsilon array
  27:mlp_trainer.c ****     free(epsilon);
 231              		.loc 1 27 5 is_stmt 1 view .LVU60
 232 00f2 3046     		mov	r0, r6
  28:mlp_trainer.c **** }
 233              		.loc 1 28 1 is_stmt 0 view .LVU61
 234 00f4 09B0     		add	sp, sp, #36
 235              	.LCFI2:
 236              		.cfi_def_cfa_offset 36
 237              		@ sp needed
 238 00f6 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 239              	.LCFI3:
 240              		.cfi_restore 14
 241              		.cfi_restore 11
 242              		.cfi_restore 10
 243              		.cfi_restore 9
 244              		.cfi_restore 8
 245              		.cfi_restore 7
 246              		.cfi_restore 6
 247              		.cfi_restore 5
 248              		.cfi_restore 4
 249              		.cfi_def_cfa_offset 0
 250              	.LVL25:
  27:mlp_trainer.c **** }
 251              		.loc 1 27 5 view .LVU62
 252 00fa FFF7FEBF 		b	free
 253              	.LVL26:
 254              	.L11:
  27:mlp_trainer.c **** }
 255              		.loc 1 27 5 view .LVU63
 256 00fe 00BF     		.align	3
 257              	.L10:
 258 0100 0000C0FF 		.word	-4194304
 259 0104 FFFFDF41 		.word	1105199103
 260 0108 00001840 		.word	1075314688
 261              		.cfi_endproc
 262              	.LFE3:
 264              		.section	.text.randomly_shuffle,"ax",%progbits
 265              		.align	1
 266              		.global	randomly_shuffle
 267              		.syntax unified
 268              		.thumb
 269              		.thumb_func
 270              		.fpu softvfp
 272              	randomly_shuffle:
 273              	.LVL27:
 274              	.LFB4:
  29:mlp_trainer.c **** 
  30:mlp_trainer.c **** void randomly_shuffle(int* a, int n) {
 275              		.loc 1 30 38 is_stmt 1 view -0
 276              		.cfi_startproc
 277              		@ args = 0, pretend = 0, frame = 0
 278              		@ frame_needed = 0, uses_anonymous_args = 0
  31:mlp_trainer.c ****     int i, j;
 279              		.loc 1 31 5 view .LVU65
  32:mlp_trainer.c ****     srand(time(NULL));
 280              		.loc 1 32 5 view .LVU66
  30:mlp_trainer.c ****     int i, j;
 281              		.loc 1 30 38 is_stmt 0 view .LVU67
 282 0000 38B5     		push	{r3, r4, r5, lr}
 283              	.LCFI4:
 284              		.cfi_def_cfa_offset 16
 285              		.cfi_offset 3, -16
 286              		.cfi_offset 4, -12
 287              		.cfi_offset 5, -8
 288              		.cfi_offset 14, -4
  30:mlp_trainer.c ****     int i, j;
 289              		.loc 1 30 38 view .LVU68
 290 0002 0546     		mov	r5, r0
 291              		.loc 1 32 11 view .LVU69
 292 0004 0020     		movs	r0, #0
 293              	.LVL28:
  30:mlp_trainer.c ****     int i, j;
 294              		.loc 1 30 38 view .LVU70
 295 0006 0C46     		mov	r4, r1
 296              		.loc 1 32 11 view .LVU71
 297 0008 FFF7FEFF 		bl	time
 298              	.LVL29:
 299              		.loc 1 32 5 view .LVU72
 300 000c FFF7FEFF 		bl	srand
 301              	.LVL30:
  33:mlp_trainer.c ****     for (i = n-1; i > 0; i--) {
 302              		.loc 1 33 5 is_stmt 1 view .LVU73
 303              	.L15:
 304              		.loc 1 33 26 discriminator 3 view .LVU74
 305              		.loc 1 33 27 is_stmt 0 discriminator 3 view .LVU75
 306 0010 013C     		subs	r4, r4, #1
 307              	.LVL31:
 308              		.loc 1 33 19 is_stmt 1 discriminator 3 view .LVU76
 309              		.loc 1 33 5 is_stmt 0 discriminator 3 view .LVU77
 310 0012 002C     		cmp	r4, #0
 311 0014 00DC     		bgt	.L14
  34:mlp_trainer.c ****         j = rand() % (i+1);
  35:mlp_trainer.c ****         int temp = a[i];
  36:mlp_trainer.c ****         a[i] = a[j];
  37:mlp_trainer.c ****         a[j] = temp;
  38:mlp_trainer.c ****     }
  39:mlp_trainer.c **** }
 312              		.loc 1 39 1 view .LVU78
 313 0016 38BD     		pop	{r3, r4, r5, pc}
 314              	.LVL32:
 315              	.L14:
 316              	.LBB2:
  34:mlp_trainer.c ****         j = rand() % (i+1);
 317              		.loc 1 34 9 is_stmt 1 discriminator 3 view .LVU79
  34:mlp_trainer.c ****         j = rand() % (i+1);
 318              		.loc 1 34 13 is_stmt 0 discriminator 3 view .LVU80
 319 0018 FFF7FEFF 		bl	rand
 320              	.LVL33:
  35:mlp_trainer.c ****         a[i] = a[j];
 321              		.loc 1 35 9 is_stmt 1 discriminator 3 view .LVU81
  34:mlp_trainer.c ****         j = rand() % (i+1);
 322              		.loc 1 34 11 is_stmt 0 discriminator 3 view .LVU82
 323 001c 631C     		adds	r3, r4, #1
 324 001e 90FBF3F1 		sdiv	r1, r0, r3
 325 0022 01FB1300 		mls	r0, r1, r3, r0
 326              	.LVL34:
  35:mlp_trainer.c ****         a[i] = a[j];
 327              		.loc 1 35 13 discriminator 3 view .LVU83
 328 0026 55F82420 		ldr	r2, [r5, r4, lsl #2]
 329              	.LVL35:
  36:mlp_trainer.c ****         a[j] = temp;
 330              		.loc 1 36 9 is_stmt 1 discriminator 3 view .LVU84
  36:mlp_trainer.c ****         a[j] = temp;
 331              		.loc 1 36 17 is_stmt 0 discriminator 3 view .LVU85
 332 002a 55F82030 		ldr	r3, [r5, r0, lsl #2]
  36:mlp_trainer.c ****         a[j] = temp;
 333              		.loc 1 36 14 discriminator 3 view .LVU86
 334 002e 45F82430 		str	r3, [r5, r4, lsl #2]
  37:mlp_trainer.c ****     }
 335              		.loc 1 37 9 is_stmt 1 discriminator 3 view .LVU87
  37:mlp_trainer.c ****     }
 336              		.loc 1 37 14 is_stmt 0 discriminator 3 view .LVU88
 337 0032 45F82020 		str	r2, [r5, r0, lsl #2]
 338 0036 EBE7     		b	.L15
 339              	.LBE2:
 340              		.cfi_endproc
 341              	.LFE4:
 343              		.section	.rodata.str1.1,"aMS",%progbits,1
 344              	.LC0:
 345 0000 49746572 		.ascii	"Iteration %d of %d(max)\015\000"
 345      6174696F 
 345      6E202564 
 345      206F6620 
 345      2564286D 
 346              		.section	.text.mlp_trainer,"ax",%progbits
 347              		.align	1
 348              		.global	mlp_trainer
 349              		.syntax unified
 350              		.thumb
 351              		.thumb_func
 352              		.fpu softvfp
 354              	mlp_trainer:
 355              	.LVL36:
 356              	.LFB5:
  40:mlp_trainer.c **** 
  41:mlp_trainer.c **** void mlp_trainer(parameters* param, int* layer_sizes) {
 357              		.loc 1 41 55 is_stmt 1 view -0
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 8
 360              		@ frame_needed = 0, uses_anonymous_args = 0
  42:mlp_trainer.c ****     // Total number of layers
  43:mlp_trainer.c ****     int n_layers = param->n_hidden + 2;
 361              		.loc 1 43 5 view .LVU90
  41:mlp_trainer.c ****     // Total number of layers
 362              		.loc 1 41 55 is_stmt 0 view .LVU91
 363 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 364              	.LCFI5:
 365              		.cfi_def_cfa_offset 36
 366              		.cfi_offset 4, -36
 367              		.cfi_offset 5, -32
 368              		.cfi_offset 6, -28
 369              		.cfi_offset 7, -24
 370              		.cfi_offset 8, -20
 371              		.cfi_offset 9, -16
 372              		.cfi_offset 10, -12
 373              		.cfi_offset 11, -8
 374              		.cfi_offset 14, -4
 375              		.loc 1 43 9 view .LVU92
 376 0004 0468     		ldr	r4, [r0]
 377 0006 0234     		adds	r4, r4, #2
 378              	.LVL37:
  44:mlp_trainer.c **** 
  45:mlp_trainer.c ****     // Create memory for arrays of inputs to the layers
  46:mlp_trainer.c ****     double** layer_inputs = (double**)calloc(n_layers, sizeof(double*));
 379              		.loc 1 46 5 is_stmt 1 view .LVU93
  41:mlp_trainer.c ****     // Total number of layers
 380              		.loc 1 41 55 is_stmt 0 view .LVU94
 381 0008 85B0     		sub	sp, sp, #20
 382              	.LCFI6:
 383              		.cfi_def_cfa_offset 56
  41:mlp_trainer.c ****     // Total number of layers
 384              		.loc 1 41 55 view .LVU95
 385 000a 0546     		mov	r5, r0
 386 000c 8846     		mov	r8, r1
 387              		.loc 1 46 39 view .LVU96
 388 000e 2046     		mov	r0, r4
 389              	.LVL38:
 390              		.loc 1 46 39 view .LVU97
 391 0010 0421     		movs	r1, #4
 392              	.LVL39:
 393              		.loc 1 46 39 view .LVU98
 394 0012 FFF7FEFF 		bl	calloc
 395              	.LVL40:
  47:mlp_trainer.c **** 
  48:mlp_trainer.c ****     int i;
  49:mlp_trainer.c ****     for (i = 0; i < n_layers; i++)
 396              		.loc 1 49 12 view .LVU99
 397 0016 0027     		movs	r7, #0
  46:mlp_trainer.c **** 
 398              		.loc 1 46 39 view .LVU100
 399 0018 0646     		mov	r6, r0
 400              	.LVL41:
  48:mlp_trainer.c ****     for (i = 0; i < n_layers; i++)
 401              		.loc 1 48 5 is_stmt 1 view .LVU101
 402              		.loc 1 49 5 view .LVU102
 403              	.L17:
 404              		.loc 1 49 17 discriminator 1 view .LVU103
 405              		.loc 1 49 5 is_stmt 0 discriminator 1 view .LVU104
 406 001a A742     		cmp	r7, r4
 407 001c 2EDB     		blt	.L18
  50:mlp_trainer.c ****         layer_inputs[i] = (double*)calloc(layer_sizes[i], sizeof(double));
  51:mlp_trainer.c **** 
  52:mlp_trainer.c ****     // Create memory for arrays of outputs from the layers
  53:mlp_trainer.c ****     double** layer_outputs = (double**)calloc(n_layers, sizeof(double*));
 408              		.loc 1 53 5 is_stmt 1 view .LVU105
 409              		.loc 1 53 40 is_stmt 0 view .LVU106
 410 001e 0421     		movs	r1, #4
 411 0020 2046     		mov	r0, r4
 412 0022 FFF7FEFF 		bl	calloc
 413              	.LVL42:
  54:mlp_trainer.c **** 
  55:mlp_trainer.c ****     for (i = 0; i < n_layers; i++)
 414              		.loc 1 55 12 view .LVU107
 415 0026 4FF00009 		mov	r9, #0
  53:mlp_trainer.c **** 
 416              		.loc 1 53 40 view .LVU108
 417 002a 0746     		mov	r7, r0
 418              	.LVL43:
 419              		.loc 1 55 5 is_stmt 1 view .LVU109
 420              	.L19:
 421              		.loc 1 55 17 discriminator 1 view .LVU110
 422              		.loc 1 55 5 is_stmt 0 discriminator 1 view .LVU111
 423 002c A145     		cmp	r9, r4
 424 002e 2EDB     		blt	.L20
  56:mlp_trainer.c ****         layer_outputs[i] = (double*)calloc(layer_sizes[i]+1, sizeof(double));
  57:mlp_trainer.c **** 
  58:mlp_trainer.c ****     // Initialize the weights
  59:mlp_trainer.c ****     initialize_weights(param, n_layers, layer_sizes);
 425              		.loc 1 59 5 is_stmt 1 view .LVU112
 426 0030 4246     		mov	r2, r8
 427 0032 2146     		mov	r1, r4
 428 0034 2846     		mov	r0, r5
 429 0036 FFF7FEFF 		bl	initialize_weights
 430              	.LVL44:
  60:mlp_trainer.c **** 
  61:mlp_trainer.c ****     int* indices = (int*)calloc(param->train_sample_size, sizeof(int));
 431              		.loc 1 61 5 view .LVU113
 432              		.loc 1 61 38 is_stmt 0 view .LVU114
 433 003a D5F834A0 		ldr	r10, [r5, #52]
 434              		.loc 1 61 26 view .LVU115
 435 003e 0421     		movs	r1, #4
 436 0040 5046     		mov	r0, r10
 437 0042 FFF7FEFF 		bl	calloc
 438              	.LVL45:
  62:mlp_trainer.c ****     for (i = 0; i < param->train_sample_size; i++)
 439              		.loc 1 62 12 view .LVU116
 440 0046 0023     		movs	r3, #0
  61:mlp_trainer.c ****     for (i = 0; i < param->train_sample_size; i++)
 441              		.loc 1 61 26 view .LVU117
 442 0048 8146     		mov	r9, r0
 443              	.LVL46:
 444              		.loc 1 62 5 is_stmt 1 view .LVU118
 445              	.L21:
 446              		.loc 1 62 17 discriminator 1 view .LVU119
 447              		.loc 1 62 5 is_stmt 0 discriminator 1 view .LVU120
 448 004a 9A45     		cmp	r10, r3
 449 004c 2ADC     		bgt	.L22
  63:mlp_trainer.c ****         indices[i] = i;
  64:mlp_trainer.c **** 
  65:mlp_trainer.c ****     // Train the MLP
  66:mlp_trainer.c ****     int training_example, j;
  67:mlp_trainer.c ****     for (i = 0; i < param->n_iterations_max; i++) {
 450              		.loc 1 67 12 view .LVU121
 451 004e 4FF0000A 		mov	r10, #0
 452              	.LVL47:
 453              	.L23:
 454              		.loc 1 67 17 is_stmt 1 discriminator 1 view .LVU122
 455              		.loc 1 67 26 is_stmt 0 discriminator 1 view .LVU123
 456 0052 AA69     		ldr	r2, [r5, #24]
 457              		.loc 1 67 5 discriminator 1 view .LVU124
 458 0054 5245     		cmp	r2, r10
 459 0056 29DC     		bgt	.L26
  68:mlp_trainer.c ****         printf("Iteration %d of %d(max)\r", i+1, param->n_iterations_max);
  69:mlp_trainer.c ****         // Randomly shuffle the data
  70:mlp_trainer.c ****         randomly_shuffle(indices, param->train_sample_size);
  71:mlp_trainer.c **** 
  72:mlp_trainer.c ****         for (j = 0; j < param->train_sample_size; j++) {
  73:mlp_trainer.c ****             training_example = indices[j];
  74:mlp_trainer.c ****             // Perform forward propagation on the jth training example
  75:mlp_trainer.c ****             forward_propagation(param, training_example, n_layers, layer_sizes, layer_inputs, layer
  76:mlp_trainer.c **** 
  77:mlp_trainer.c ****             // Calculate the error
  78:mlp_trainer.c **** 
  79:mlp_trainer.c ****             // Perform back propagation and update weights
  80:mlp_trainer.c ****             back_propagation(param, training_example, n_layers, layer_sizes, layer_inputs, layer_ou
  81:mlp_trainer.c ****         }   
  82:mlp_trainer.c ****     }
  83:mlp_trainer.c **** 
  84:mlp_trainer.c ****     // Free the memory allocated in Heap
  85:mlp_trainer.c ****     free(indices);
 460              		.loc 1 85 5 is_stmt 1 view .LVU125
 461 0058 4846     		mov	r0, r9
 462 005a FFF7FEFF 		bl	free
 463              	.LVL48:
  86:mlp_trainer.c **** 
  87:mlp_trainer.c ****     for (i = 0; i < n_layers; i++)
 464              		.loc 1 87 5 view .LVU126
 465              		.loc 1 87 12 is_stmt 0 view .LVU127
 466 005e 0025     		movs	r5, #0
 467              	.LVL49:
 468              	.L27:
 469              		.loc 1 87 17 is_stmt 1 discriminator 1 view .LVU128
 470              		.loc 1 87 5 is_stmt 0 discriminator 1 view .LVU129
 471 0060 A542     		cmp	r5, r4
 472 0062 47DB     		blt	.L28
  88:mlp_trainer.c ****         free(layer_outputs[i]);
  89:mlp_trainer.c **** 
  90:mlp_trainer.c ****     free(layer_outputs);
 473              		.loc 1 90 5 is_stmt 1 view .LVU130
 474 0064 3846     		mov	r0, r7
 475 0066 FFF7FEFF 		bl	free
 476              	.LVL50:
  91:mlp_trainer.c **** 
  92:mlp_trainer.c ****     for (i = 0; i < n_layers; i++)
 477              		.loc 1 92 5 view .LVU131
 478              		.loc 1 92 12 is_stmt 0 view .LVU132
 479 006a 0025     		movs	r5, #0
 480              	.LVL51:
 481              	.L29:
 482              		.loc 1 92 17 is_stmt 1 discriminator 1 view .LVU133
 483              		.loc 1 92 5 is_stmt 0 discriminator 1 view .LVU134
 484 006c A542     		cmp	r5, r4
 485 006e 47DB     		blt	.L30
  93:mlp_trainer.c ****         free(layer_inputs[i]);
  94:mlp_trainer.c **** 
  95:mlp_trainer.c ****     free(layer_inputs);
 486              		.loc 1 95 5 is_stmt 1 view .LVU135
 487 0070 3046     		mov	r0, r6
  96:mlp_trainer.c **** }
 488              		.loc 1 96 1 is_stmt 0 view .LVU136
 489 0072 05B0     		add	sp, sp, #20
 490              	.LCFI7:
 491              		.cfi_remember_state
 492              		.cfi_def_cfa_offset 36
 493              		@ sp needed
 494 0074 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 495              	.LCFI8:
 496              		.cfi_restore 14
 497              		.cfi_restore 11
 498              		.cfi_restore 10
 499              		.cfi_restore 9
 500              		.cfi_restore 8
 501              		.cfi_restore 7
 502              		.cfi_restore 6
 503              		.cfi_restore 5
 504              		.cfi_restore 4
 505              		.cfi_def_cfa_offset 0
 506              	.LVL52:
  95:mlp_trainer.c **** }
 507              		.loc 1 95 5 view .LVU137
 508 0078 FFF7FEBF 		b	free
 509              	.LVL53:
 510              	.L18:
 511              	.LCFI9:
 512              		.cfi_restore_state
  50:mlp_trainer.c **** 
 513              		.loc 1 50 9 is_stmt 1 discriminator 3 view .LVU138
  50:mlp_trainer.c **** 
 514              		.loc 1 50 36 is_stmt 0 discriminator 3 view .LVU139
 515 007c 58F82700 		ldr	r0, [r8, r7, lsl #2]
 516 0080 0821     		movs	r1, #8
 517 0082 FFF7FEFF 		bl	calloc
 518              	.LVL54:
  50:mlp_trainer.c **** 
 519              		.loc 1 50 25 discriminator 3 view .LVU140
 520 0086 46F82700 		str	r0, [r6, r7, lsl #2]
  49:mlp_trainer.c ****         layer_inputs[i] = (double*)calloc(layer_sizes[i], sizeof(double));
 521              		.loc 1 49 31 is_stmt 1 discriminator 3 view .LVU141
  49:mlp_trainer.c ****         layer_inputs[i] = (double*)calloc(layer_sizes[i], sizeof(double));
 522              		.loc 1 49 32 is_stmt 0 discriminator 3 view .LVU142
 523 008a 0137     		adds	r7, r7, #1
 524              	.LVL55:
  49:mlp_trainer.c ****         layer_inputs[i] = (double*)calloc(layer_sizes[i], sizeof(double));
 525              		.loc 1 49 32 discriminator 3 view .LVU143
 526 008c C5E7     		b	.L17
 527              	.LVL56:
 528              	.L20:
  56:mlp_trainer.c **** 
 529              		.loc 1 56 9 is_stmt 1 discriminator 3 view .LVU144
  56:mlp_trainer.c **** 
 530              		.loc 1 56 58 is_stmt 0 discriminator 3 view .LVU145
 531 008e 58F82900 		ldr	r0, [r8, r9, lsl #2]
  56:mlp_trainer.c **** 
 532              		.loc 1 56 37 discriminator 3 view .LVU146
 533 0092 0821     		movs	r1, #8
 534 0094 0130     		adds	r0, r0, #1
 535 0096 FFF7FEFF 		bl	calloc
 536              	.LVL57:
  56:mlp_trainer.c **** 
 537              		.loc 1 56 26 discriminator 3 view .LVU147
 538 009a 47F82900 		str	r0, [r7, r9, lsl #2]
  55:mlp_trainer.c ****         layer_outputs[i] = (double*)calloc(layer_sizes[i]+1, sizeof(double));
 539              		.loc 1 55 31 is_stmt 1 discriminator 3 view .LVU148
  55:mlp_trainer.c ****         layer_outputs[i] = (double*)calloc(layer_sizes[i]+1, sizeof(double));
 540              		.loc 1 55 32 is_stmt 0 discriminator 3 view .LVU149
 541 009e 09F10109 		add	r9, r9, #1
 542              	.LVL58:
  55:mlp_trainer.c ****         layer_outputs[i] = (double*)calloc(layer_sizes[i]+1, sizeof(double));
 543              		.loc 1 55 32 discriminator 3 view .LVU150
 544 00a2 C3E7     		b	.L19
 545              	.LVL59:
 546              	.L22:
  63:mlp_trainer.c **** 
 547              		.loc 1 63 9 is_stmt 1 discriminator 3 view .LVU151
  63:mlp_trainer.c **** 
 548              		.loc 1 63 20 is_stmt 0 discriminator 3 view .LVU152
 549 00a4 49F82330 		str	r3, [r9, r3, lsl #2]
  62:mlp_trainer.c ****         indices[i] = i;
 550              		.loc 1 62 47 is_stmt 1 discriminator 3 view .LVU153
  62:mlp_trainer.c ****         indices[i] = i;
 551              		.loc 1 62 48 is_stmt 0 discriminator 3 view .LVU154
 552 00a8 0133     		adds	r3, r3, #1
 553              	.LVL60:
  62:mlp_trainer.c ****         indices[i] = i;
 554              		.loc 1 62 48 discriminator 3 view .LVU155
 555 00aa CEE7     		b	.L21
 556              	.LVL61:
 557              	.L26:
  68:mlp_trainer.c ****         // Randomly shuffle the data
 558              		.loc 1 68 9 is_stmt 1 view .LVU156
 559 00ac 0AF1010A 		add	r10, r10, #1
 560              	.LVL62:
  68:mlp_trainer.c ****         // Randomly shuffle the data
 561              		.loc 1 68 9 is_stmt 0 view .LVU157
 562 00b0 5146     		mov	r1, r10
 563 00b2 1648     		ldr	r0, .L31
 564 00b4 FFF7FEFF 		bl	printf
 565              	.LVL63:
  70:mlp_trainer.c **** 
 566              		.loc 1 70 9 is_stmt 1 view .LVU158
 567 00b8 696B     		ldr	r1, [r5, #52]
 568 00ba 4846     		mov	r0, r9
 569 00bc FFF7FEFF 		bl	randomly_shuffle
 570              	.LVL64:
  72:mlp_trainer.c ****             training_example = indices[j];
 571              		.loc 1 72 9 view .LVU159
  72:mlp_trainer.c ****             training_example = indices[j];
 572              		.loc 1 72 16 is_stmt 0 view .LVU160
 573 00c0 4FF0000B 		mov	fp, #0
 574              	.LVL65:
 575              	.L24:
  72:mlp_trainer.c ****             training_example = indices[j];
 576              		.loc 1 72 21 is_stmt 1 discriminator 1 view .LVU161
  72:mlp_trainer.c ****             training_example = indices[j];
 577              		.loc 1 72 9 is_stmt 0 discriminator 1 view .LVU162
 578 00c4 6B6B     		ldr	r3, [r5, #52]
 579 00c6 5B45     		cmp	r3, fp
 580 00c8 C3DD     		ble	.L23
  73:mlp_trainer.c ****             // Perform forward propagation on the jth training example
 581              		.loc 1 73 13 is_stmt 1 discriminator 3 view .LVU163
  73:mlp_trainer.c ****             // Perform forward propagation on the jth training example
 582              		.loc 1 73 30 is_stmt 0 discriminator 3 view .LVU164
 583 00ca 59F82B10 		ldr	r1, [r9, fp, lsl #2]
 584              	.LVL66:
  75:mlp_trainer.c **** 
 585              		.loc 1 75 13 is_stmt 1 discriminator 3 view .LVU165
 586 00ce 0391     		str	r1, [sp, #12]
 587 00d0 4346     		mov	r3, r8
 588 00d2 2246     		mov	r2, r4
 589 00d4 2846     		mov	r0, r5
 590 00d6 CDE90067 		strd	r6, r7, [sp]
 591 00da FFF7FEFF 		bl	forward_propagation
 592              	.LVL67:
  80:mlp_trainer.c ****         }   
 593              		.loc 1 80 13 discriminator 3 view .LVU166
 594 00de CDE90067 		strd	r6, r7, [sp]
 595 00e2 0399     		ldr	r1, [sp, #12]
 596 00e4 4346     		mov	r3, r8
 597 00e6 2246     		mov	r2, r4
 598 00e8 2846     		mov	r0, r5
 599 00ea FFF7FEFF 		bl	back_propagation
 600              	.LVL68:
  72:mlp_trainer.c ****             training_example = indices[j];
 601              		.loc 1 72 51 discriminator 3 view .LVU167
  72:mlp_trainer.c ****             training_example = indices[j];
 602              		.loc 1 72 52 is_stmt 0 discriminator 3 view .LVU168
 603 00ee 0BF1010B 		add	fp, fp, #1
 604              	.LVL69:
  72:mlp_trainer.c ****             training_example = indices[j];
 605              		.loc 1 72 52 discriminator 3 view .LVU169
 606 00f2 E7E7     		b	.L24
 607              	.LVL70:
 608              	.L28:
  88:mlp_trainer.c **** 
 609              		.loc 1 88 9 is_stmt 1 discriminator 3 view .LVU170
 610 00f4 57F82500 		ldr	r0, [r7, r5, lsl #2]
 611 00f8 FFF7FEFF 		bl	free
 612              	.LVL71:
  87:mlp_trainer.c ****         free(layer_outputs[i]);
 613              		.loc 1 87 31 discriminator 3 view .LVU171
  87:mlp_trainer.c ****         free(layer_outputs[i]);
 614              		.loc 1 87 32 is_stmt 0 discriminator 3 view .LVU172
 615 00fc 0135     		adds	r5, r5, #1
 616              	.LVL72:
  87:mlp_trainer.c ****         free(layer_outputs[i]);
 617              		.loc 1 87 32 discriminator 3 view .LVU173
 618 00fe AFE7     		b	.L27
 619              	.L30:
  93:mlp_trainer.c **** 
 620              		.loc 1 93 9 is_stmt 1 discriminator 3 view .LVU174
 621 0100 56F82500 		ldr	r0, [r6, r5, lsl #2]
 622 0104 FFF7FEFF 		bl	free
 623              	.LVL73:
  92:mlp_trainer.c ****         free(layer_inputs[i]);
 624              		.loc 1 92 31 discriminator 3 view .LVU175
  92:mlp_trainer.c ****         free(layer_inputs[i]);
 625              		.loc 1 92 32 is_stmt 0 discriminator 3 view .LVU176
 626 0108 0135     		adds	r5, r5, #1
 627              	.LVL74:
  92:mlp_trainer.c ****         free(layer_inputs[i]);
 628              		.loc 1 92 32 discriminator 3 view .LVU177
 629 010a AFE7     		b	.L29
 630              	.L32:
 631              		.align	2
 632              	.L31:
 633 010c 00000000 		.word	.LC0
 634              		.cfi_endproc
 635              	.LFE5:
 637              		.text
 638              	.Letext0:
 639              		.file 2 "parameters.h"
 640              		.file 3 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\stdlib.h"
 641              		.file 4 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\stdio.h"
 642              		.file 5 "forward_propagation.h"
 643              		.file 6 "back_propagation.h"
 644              		.file 7 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\time.h"
 645              		.file 8 "c:\\users\\joris\\chipwh~1\\cw\\home\\portable\\armgcc\\arm-none-eabi\\include\\math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mlp_trainer.c
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:20     .text.initialize_weights:00000000 $t
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:28     .text.initialize_weights:00000000 initialize_weights
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:258    .text.initialize_weights:00000100 $d
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:265    .text.randomly_shuffle:00000000 $t
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:272    .text.randomly_shuffle:00000000 randomly_shuffle
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:347    .text.mlp_trainer:00000000 $t
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:354    .text.mlp_trainer:00000000 mlp_trainer
C:\Users\joris\AppData\Local\Temp\ccjbWySD.s:633    .text.mlp_trainer:0000010c $d

UNDEFINED SYMBOLS
__aeabi_i2d
__aeabi_ddiv
__aeabi_dadd
__aeabi_dsub
time
srand
calloc
sqrt
rand
free
printf
forward_propagation
back_propagation
